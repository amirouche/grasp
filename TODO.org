* 14.06.2023

wstepnie wyglada na to, ze Scroll w terminalu dziala
(choc cos sie z jakichs wzgledow jeszcze zawiesza)

no to teraz tak: w klientach graficznych bysmy chcieli
ladowac svg, natomiast w kliencie tekstowym
po prostu uzylibysmy ikonek z unicode'a

üìÅ ..
üìÑ file.grasp

po stronie paintera bysmy zrobili

(draw-directory-icon!)::void
(directory-icon-size)::Extent
(draw-file-icon!)::void
(file-icon-size)::Extent

duzo chyba teraz bedzie rozkminy koncepcyjnej, bo
na androidzie przegladarka plikow musi miec uprawnienia,
ale u pozostalych klientow juz niekoniecznie

no dobra, to odgrzebmy moze dzialanie starej przegladarki


lomNg press powoduje wstawienie pop-upu OpenFileBrowser
albo SaveFileBrowser, ktore implementuja (nasz wlasny)
interfejs PermissiomGrantedHandler, ktory dziala tak,
ze w klasie GRASP mamy metodd

@override
public void onRequestPermissionsResult(
  int requestCode,
  String[] permissions,
  int[] grantResults
)

no dobra. ale teraz takie pytanie:
w jaki sposob zroznicowac obsluge plikow
w kliencie androidowym i pozostalych?

moze opiszmy sobie jak dziala OpenFileBrowser:
ma metode perform, ktora jest wywolywana
przy nacisnieciu przycisku Open w menu edytowa

kiedy do tego dojdzie, zostaje wywolane zapytanie
o dostep do plikow, a jako kontynuacja zostaje
ustawiony sam ten obiekt.

za wywolanie kontynuacji odpowiada system, i to
on wywola metode onPermissionGranted, ktora
tworzy nowe okienko

gdybysmy chcieli dodac te funkcje do paintera,
to bysmy mieli metody

(define-interface Keeper ()
  (with-read-permissions action::(maps (...) to: void))::void
  (with-write-permissions action::(maps (...) to: void))::void
)

(define-object (PermissiveKeeper)::Keeper
  (define (with-read-permissions action::(maps () to: void))::void
    (action))
  (define (with-write-permissions action::(maps () to: void))::void
    (action)))

(define-parameter (the-keeper)::Keeper (PermissiveKeeper))


* 13.06.2023

wyglada na to, ze implementacja with-clip jest niepoorawna,
a lezace u jej podstaw funkcjonalnosci niedostateczne
do dostarczenia poprawnej implementacji.

Dlatego dzis skupilibysmy sie na tym, zeby odpowiednio
rozbudowac paintera

Zamiast

(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter (the-painter)))
    (let ((x0 (invoke painter 'current-clip-left))
	  (y0 (invoke painter 'current-clip-top))
	  (w0 (invoke painter 'current-clip-width))
	  (h0 (invoke painter 'current-clip-height))
	  (x! (invoke painter 'current-translation-left))
	  (y! (invoke painter 'current-translation-top))
	  (w! w)
	  (h! h))
      (invoke painter 'clip! x! y! w! h!)
      (begin . actions)
      (invoke painter 'clip! x0 y0 w0 h0))))

chcielibysmy raczej miec

(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter ::Painter (the-painter)))
      (painter:store-state!)
      (painter:clip! w h)
      (begin . actions)
      (painter:restore-state!))

znow musimy porownac Androida, AWT i terminal.
W terminalu musimy wszytskie mechanizmy
sami zaimplementowac i tak.


w starym kliencie Androidowym mielismy

canvas.save();
canvas.clipRect(0, 0, _width, _height);
canvas.translate(-hscroll, -vscroll);
target.render(canvas);
canvas.restore();

byc moze w Androidzie mozna uzyc pary

clipRect

clipOutRect

natomiast w awt mozemy zrobic tak:


(let ((previous-clip ::Shape (graphics:getClip)))
  (graphics:clipRect ...)

  (graphics:setClip previous-clip))


(define-alias ClipState java.lang.Object)

(clip! width::real height::real)::Clip
(restore-clip! clip::Clip)::void

(define-syntax-rule (with-clip (w h) . actions)
  (let* ((painter ::Painter (the-painter))
         (previous ::Clip (painter:clip! w h)))
      (begin . actions)
      (painter:restore-clip! previous)))

i w kliencie awt to by bylo:

(define (clip! w h)::Clip
(let* ((previous-clip (graphics:getClip))
         (transform ::AffineTransform
 		      (graphics:getTransform))
         (x (transform:getTranslateX))
	 (y (transform:getTranslateY)))
    (graphics:setClip x y w h)))

(define (restote-clip! clip::Clip)::void
  (graphics:setClip (as Shape clip)))


a w kliencie androidowym

(define (clip! w h)::Clip
  (let ((clip ::RectF (RectF 0 0 w h)))
    (canvas:clipRect clip)
    clip))


(define (restote-clip! clip::Clip)::void

a moze po prodtu dodac:

(with-clip w::real h::real action::(maps () to: void))

no, to na tym w koncu stanelo. jak na razie dziala
na desktopie i androidzie, zas terminal musi jeszcze zostac
przetestowany

wydaje sie, ze nastepnym krokiem jest implementacja
przegladarki plikiw - i tutaj chyba najrozsadniej
jest zaczac od implementacji przegladarki plikow
z poprzedniego prototypu

i wyglada na to, ze:
- w kliencie androidowym chcemy dodac biblioteke android-svg
- a do klienta desktopowego bysmy sprobowali jsvg



* 12.06.2023

mamy juz wyswietlanie menu w kliencie terminalowym,
a teraz bysmy sie postarali, zeby miec to samo
na androidzie i na desktopie

zasadniczo mamy to, ale nie wyglada to tak, jak bysmy
tego chcieli: funkcja do rysowania grida powinna
rysowac biale tlo

czyli do paintera powinnismy dodac

(fill-grid-cell! width::real height::real)::void

Ok, a jak to juz bedziemy mieli, to co wtedy bedzie?

W dalszym kroku bedziemy chcieli zrobic widget Scrollable
oraz przegladarke plikow.

A kiedy to juz bedzie, zrobimy ladowanie plikow oraz
okienko "Switch to...", zamiemy sie scrollowaniem okna edytora

**** I od tego momentu mozemy juz probowac rozwijac GRASP w GRASP.

I kiedy to juz bedzie, zrobimy dzielenie ekranu
oraz wstepny zarys systemu do rozpoznawania gestow.

No ale dobra. Teraz zajmijmy sie Scrollem.

(define-type (Scroll width: real
                     height: real
		     left: real := 0
		     top: real := 0
		     content: Enchanted)
  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (let ((inner ::Extent (content:extent)))
     (set! left (max 0 (min (- inner:width width) (- left dx))))
     (set! top (max 0 (min (- inner:height height) (- top dy))))))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Enchanted
  with
  ((draw! context::Cursor)::void
   (with-clip (width height)
     (with-translation ((- left) (- top))
       (content:draw! (recons 0 context)))))

  ((tap! finger::byte  x::real y::real)::boolean
   (content:tap! finger (- x left) (- y real)))

  ((press! finger::byte x::real y::real)::boolean
   (screen:drag! finger (this)))

  ((second-press! finger::byte #;at x::real y::real)::boolean
    (content:press! finger (- x left) (- y real)))

  ((double-tap! finger::byte x::real y::real)::boolean
    (content:double-tap! finger (- x left) (- y real)))

  ((long-press! finger::byte x::real y::real)::boolean
    (content:long-press! finger (- x left) (- y real)))

  ((key-typed! key-code::long)::boolean
    (content:key-typed! key-code))

  ((extent)::Extent
   (Extent width: width
           height: height))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (content:cursor-under* (- x left) (- y top) (recons 0 path)))

  ((part-at index::Index)::Indexable* content)

  ((first-index)::Index 0)

  ((last-index)::Index 0)

  ((next-index index::Index)::Index 0)

  ((previous-index index::Index)::Index 0)

  ((index< a::Index b::Index)::boolean #f)

  ((as-expression)::cons
   (invoke-special Base 'to-list cons to-expression)))

* 11.06.2023

No dobra, to teraz chcemy dodac nowe widgety:

(define-type (Link on-tap: (maps (Link byte real real) to: boolean) := always
                   on-double-tap: (maps (Link byte real real) to: boolean) := always
                   on-press: (maps (Link byte real real) to: boolean) := always
                   on-second-press: (maps (Link byte real real) to: boolean) := always
                   on-long-press: (maps (Link byte real real) to: boolean) := always
                   on-key: (maps (Link char) to: boolean) := always
                   content: Enchanted)
  implementing Enchanted
  with


* 10.06.2023

Na razie bedziemy dodawac do modulu (button):
- ColumnGrid
- Capture
- Caption

ale tez musimy dodac 3 metody do Painter
(na razie do TextPainter)

  (define 4dirs-code
    (let ((4dirs (mapping (4p::char)::int 0)))
      (set! (4dirs #\space) #b0000)
      (set! (4dirs #\‚ïµ) #b0001)
      (set! (4dirs #\‚ï∂) #b0010)
      (set! (4dirs #\‚îî) #b0011)
      (set! (4dirs #\‚ï∑) #b0100)
      (set! (4dirs #\‚îÇ) #b0101)
      (set! (4dirs #\‚îå) #b0110)
      (set! (4dirs #\‚îú) #b0111)
      (set! (4dirs #\‚ï¥) #b1000)
      (set! (4dirs #\‚îò) #b1001)
      (set! (4dirs #\‚îÄ) #b1010)
      (set! (4dirs #\‚î¥) #b1011)
      (set! (4dirs #\‚îê) #b1100)
      (set! (4dirs #\‚î§) #b1101)
      (set! (4dirs #\‚î¨) #b1110)
      (set! (4dirs #\‚îº) #b1111)
      4dirs))

  (define 4dirs ::char[]
    (char[] #\space
	 #\‚ïµ #\‚ï∂ #\‚îî #\‚ï∑ #\‚îÇ
	 #\‚îå #\‚îú #\‚ï¥ #\‚îò #\‚îÄ
	 #\‚î¥ #\‚îê #\‚î§ #\‚î¨ #\‚îº))

  (define (4dirs-put! c::char x::int y::int)::void
    (put! (4dirs (bitwise-ior
                  (4dirs-code (get y x))
                  (4dirs-code c))) y x))

* 09.06.2023

mamy z grubsza zarysowane metody draw! i extent,
ale do pelni szczescia bylyby nam jeszcze potrzebne:

  (define (part-at index::Index)::Indexable*
    (items index))

  (define (first-index)::Index 0)
  (define (last-index)::Index (- (length items 1)))

  (define (next-index index::Index)::Index
    (min (+ index 1) (last-index)))

  (define (previous-index index::Index)::Index
    (max 0 (- index 1)))

  (define (index< a::Index b::Index)::boolean
    (is a < b)) ;>>

przy czym te ostatnie raczej powinny byc robione
na jedno kopyto (analogicznie do tego jak zrobilismy
tego PopUpa)

(define (propagate finger::byte x::real y::real
                   action::(maps (Enchanted byte real real int) to: ?))
  (let* ((painter ::Painter (the-painter))
         (grid-border ::real (painter:grid-border))
	 (ceiling ::real grid-border)
	 (n ::real 0))
    (call/cc
      (lambda (return)
        (for item::Enchanted in items
          (let ((inner ::Extent (item:extent)))
	    (when (is ceiling < y < (+ celiing inner:height));>>
	      (return (action item finger
	                 (- x grid-border) (- y ceiling))))
	      (set! ceiling (+ inner:height grid-border))
	      (set! n (+ n 1))))
	#f))))

  (define (cursor-under* x::real y::real path::Cursor)::Cursor*
    (otherwise #!null
      (propagate 0 x y
        (lambda (item::Enchanted finger::byte x::real y::real
                 index::int)::boolean
          (item:cursor-under* x y (recons index path))))))

  (define (tap! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:tap! finger x y))))

  (define (press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:press! finger x y))))

  (define (second-press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:second-press! finger x y))))

  (define (double-tap! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:double-tap! finger x y))))

  (define (long-press! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:long-press! finger x y))))

  (define (key-typed! key-code::long)::boolean
    ;; na razie tego nie obslugujemy; docelowo warto by bylo
    ;; przemyslec obsluge klawiatury
    #f)

* 08-07.06.2023

mamy zintegrowany touch event processor
- no i super, i teraz musimy to przetestowac,
  i zajac sie implementacja ButtonList
  (czyli po stronie paintera to bedzie
  rysowanie i wymiarowanie gridow)

Tyle ze to nie bedzie ButtonList.
To bedzie raczej cos w rodzaju

(Link content: (Caption "Open...")
      action: ...)

czyli Link bedzie troche jak Button

Natomiast tabele bysmy budowali tak,
ze mamy

(Table
 (Column
  (Row content: (Link content: ...)
       span: 1)


Niewazne, nie skupiajmy sie na razie na tabeli.

W razie czego to sobie przemodelujemy
Natomiast teraz pytanie jest takie, jak sie
z tym uporac od strony paintera?

Na pewno musimy zaczac od tego, zeby zmienic nazwy
metod draw-horizontal-line na draw-horizontal-split itd.

ok, to juz zrobione

teraz bysmy dodali do paintera
draw-horizontal-grid!
draw-vertical-grid!
grid-border



Jak powinien wygladac kod renderujacy
ButtonList?

(define (column . items)
  (Column items))


(define-object (Column items::(sequence-of Enchanted))::Enchanted
  (define (extent)::Extent
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
           (max-width ::real 0)
           (total-height ::real grid-border))
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (set! max-width (max max-width inner:width))
	  (set! total-height
	        (+ total-height inner:height grid-border))))
      (Extent width: (+ max-width (* 2 grid-border))
              height: total-height)))

  (define (draw! context::Cursor)::void
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
	   (total ::Extent (extent))
           (n ::int 0)
           (x0 ::real (painter:current-translation-left))
	   (y0 ::real (painter:current-translation-top)))
      (painter:translate! grid-border grid-border)
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (item:draw! (recons n context))
	  (painter:translate! 0 inner:height)
	  (painter:draw-horizontal-grid! total:width)
	  (painter:translate! 0 grid-border)
	(set! n (+ n 1))))
      (painter:translate!
       (- (painter:current-translation-left) x0)
       (- (painter:current-translation-top) y0))))




* 06.06.2023

dzisiaj priorytetem jest implementacja funkcji
do rysowania pop-upow w kliencie desktopowym,
zeby przywrocic jego budowalnosc

a jesli to sie uda, to bysmy moze sprobowali
podzialac z tym touch-event-processorem, zeby
miec juz pop-upy we wszystkich klientach

ok budowalnosc mamy,
to teraz sprobujemy zintegrowac touch-event-processor

z desktopem sie to chyba udalo. teraz zas
bysmy zrobili to samo, tylko dla terminala


w tym celu:
- stworzymy sobie

  (define events ::BlockingQueue
    (ArrayBlockingQueue 32))

teraz mamy:
    (let* ((editing (future (edit io)))
	   (rendering (future (render io))))
      ;; we want the rendering thread to have a lower
      ...)

stworzylibysmy sobie nowy watek:

(let* ((events ...)
       (preprocessing (future (process io events)))
       (editing (future (edit ioevents)))
       (rendering (future (render io))))
  ...)

ale do tego potrzebny bylby rowniez timer.

a moze sie uda bex tego preprocessingu, tylko
wtedy trzeba rozwazyc kwestie ewentualnych
wyscigow

w kazdym razie jak ma w teeminalu dzialac nasz EventRunner?


(define-interface CancellableRunner (Postponed Cancellable))

(define-object (EventRunner queue::BlockingQueue)
  ::CancellableRunner

  (define postponed-action ::(maps () to: boolean) never)

  (define timer ::java.util.Timer (java.util.Timer))

  (define (cancel)::Cancellable
    (invoke-special TimerTask (this) 'cancel)
    (timer:purge)
    (this))

  (define (after time-ms::long action::procedure)
    ::Cancellable
    (timer:schedule (this) time-ms)
    (this))

  (define (run)::void
    (queue:put postponed-action))

  (TimerTask))

Ok, to jakis zamysl jest (i jutro sie tym bardziej zajmiemy),
a tymczasem mozna pomalu myslec o widgecie ButtonsList
i o tym, jak to obsluzyc od strony Paintera


(define (rewrite-events io::LanternaScreen queue::BlockingQueue)::void
  ;; although a thread rewriting stuff from one place
  ;; to another may not seem very useful, the point is
  ;; to expose a queue, so that things can be added to it
  ;; asynchronously, from a timer event
  (while #t
    (let ((event ::KeyStroke (io:readInput)))
      (queue:put event))))


* 05.06.2023

mamy juz zrobione "rusztowanie" do odpalinia
pop-upow (w kliencie terminalowym i desktopowym),
teraz bysmy sprobowali to odpalic (np. dodajac
do pop-upa jakiegos buttona) i przeniesc tez
na desktopa, a jak to bedzie gotowe, to bysmy
tez zaimplementowali widget ButtonList

jak do tej pory naprawilismy tez aktualizacje
ekranu po opoznionym zdarzeniu (tap!), i jeszcze by
wypadalo zrobic rysowanie tla w guzikach w kliencie
androidowym, oraz zdebugowac zachowanie popupow

co niniejszym rowniez sie udalo

no to tetaz tak:
- dodac rysowanie pop-upa do klienta desktopowego
- zintegrowac touch-event-processor z klientem terminalowym
- zintegrowac touch-event-processor z klientem desktopowym
- zaimplementowac ButtonList
- zrobic menu glowne
- zaimplementowac przegladarke plikow
- funkcjonalnosc odczytu i zapisu
- przelaczanie dokumentow
- scrollowanie edytora
- podzial ekranu


* 04.06.2023

dzis wykonamy drugie podejscie do rozbicia pane
na mniejsze moduly

przede wszystkim, Screen musi sie stac interfejsem

po drugie, chcemy stworzyc null-objecta implementujacego
Screen, NullScreen, bedacego domyslna wartoscia screen.

po trzecie, biezacy Screen powinien sie stac RealScreen
albo ActualScreen

No dobra, chyba to mamy.

To teraz: tak naprawde wcale nie chcemy dodawac tego
okienka z poziomu ekranu, tylko z poziomu edytora.

Mozemy zatem skasowac sobie tego NullScreena, ale chcemy
wyizolowac modul editor

i teraz problem jest taki, ze ActualScreen
ma swoj 'top' ktory jest Editor.

Zamiast tego:
- top powinno sie nazywac content
- content powinien byc ustawiany w init,
  w sensie cos w rodzaju
  (screen:set-content! (Editor document: ...))

no, to teraz powinnismy juz moc dosc gladko
wyodrebnic modul edytora

i w dalszym kroku mozemy zaimportowac (popup) w module
(editor) i dodac przy akcji (long-press!) nowy pop-up
z jakims buttonem do screena

teraz trzeba jeszcze wyjasnic dlaczego w PopUp
nie ma metody "to-list" (czy aby jest klas√ø Struct
albo Base?)

* 03.06.2023

dzisiaj bysmy sprobowali dodac do tekstowego paintera
opcje rysowania plywajacych okien

to akurat chybs sie udalo :P

ale jest taki problem, ze modul (pane) ma zbyt wiele zaleznosci.

wiec chcielibysmy go rozbic na nastepujace:

- pane
- editor
- screen
- split
- stroke

* 01-02.06.2023

w najblizszym czasie chcemy zrobic takie rzeczy:
- plywajace okienka
- widget z lista guzikow
- ewentualnie mrugniecie guzika przed aktywowaniem akcji

najpierw sie zajmiemy plywajacym oknem

to by dzialalo jakos tak:

(define/kw (pop-up-action pop-up::PopUp
                          x::real y::real
                          inside: inner-action
			  ::(maps (Tile byte real real . list)
                             to: boolean) := never
                          outside: outer-action
                          ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
			  on-the-edge: boundary-action
			  ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
		          . args)
   (let* ((painter ::Painter (the-painter))
          (content ::Tile pop-up:content)
          (inner ::Extent (content:extent))
	  (horizontal ::real (painter:horizontal-popup-margin))
	  (vertical ::real (painter:vertical-popup-margin))
	  (inner-left ::real (+ left horizontal))
	  (inner-top :: (+ top horizontal))
	  (inner-right ::real (+ inner:width horizontal))
	  (inner-bottom ::real (+ inner:height vertical))
	  (right ::real (+ inner-right horizontal))
	  (botom ::real (+ inner-bottom vertical)))
     (cond ((and (is inner-left <= x < inner-right) ;>>
                 (is inner-top <= y < inner-bottom)) ;>>
	    (apply inner-action content finger
	           (- x inner-left) (- y inner-top) args))
	   ((or (is x < left) (is x > right)
	        (is y < top) (is y > bottom))
	    (apply outer-action pop-up finger x y args))
	   (else
	    (apply boundary-action pop-up finger x y args)))))


(define-type (PopUp left: real := 0 top: real := 0
                    content: Tile)

  implementing Tile
  with
  ((part-at index::Index)::Indexable*
   (match index
    ('edge (this))
    ('content content)))

  ((first-index)::Index 'edge)
  ((last-index)::Index 'content)

  ((next-index index::Index)::Index 'content)
  ((previous-index index::Index)::Index 'edge)

  ((index< a::Index b::Index)::boolean ;>
   (and (eq? a 'content) (eq? b 'edge)))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (call/cc
    (lambda (return)
     (pop-up-action (this) x y
      inside:
      (lambda (content::Tile finger::byte x::real y::real)::boolean
        (return
	 (otherwise #!null
	   (and path
	     (content:cursor-under*
	      x y (recons 'content path))))))
      outside:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return #!null))
      on-the-edge:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return
	  (otherwise #!null
	    (and path (recons 'edge path)))))))))

  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (set! left (+ left dx))
   (set! top (+ top dy)))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Pane
  with

  ((tap! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:tap! finger x y))
     outside:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (screen:overlay:remove! pop-up))
     on-the-edge:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (let ((dragging screen:dragging))
         (set! (dragging finger) pop-up)))))

  ((second-press! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:second-press! finger x y))))

  ((double-tap! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
    inside:
    (lambda (content::Tile finger::byte x::real y::real)::boolean
      (content:double-tap! finger x y))))

  ((long-press! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:long-press! finger x y))))

  ((key-typed! key-code::long)::boolean
   (content:key-typed! key-code))

  implementing Enchanted
  with
  ((as-expression)::cons
   (to-list cons to-expression))
)

(define (to-expression object)
  (match object
    (magic::Enchanted
     (magic:as-expression))
    (struct::ListSerializable
     (struct:to-list cons to-expression))
    (cell::cons
     cell)
    (cell::pair
     (cons (to-expression (car pair))
           (to-expression (cdr pair))))
    (s::symbol
     (Atom (symbol->string s))
    (,@(null? object)
     (empty))
    (n::number
     (Atom (number->string n))
    (t::Text
     t)
    (s::string
     (text s))))

(painter:draw-popup!
  (+ inner:width (* 2 (painter:horizontal-popup-margin)))
  (+ inner:height (* 2 (painter:vertical-popup-margin))))


a ogolnie "kamienie milowe" bysmy okreslili jako:
- edycja GRASP w GRASP (i wypchniecie do sklepu)
- ewaluator wizualny
- kompozycjonalny system budowania rozszerzen
- ksiazka o GRASP
- ksiazka w GRASP o komputerach

* 31.05.2023

chyba ze wzgledu na klienta terminalowego
zaimplementujemy raczej ButtonList. Czyli
cos w rodzaju

(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (ButtonList
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)

Wtedy mozemy na razie zupelnie zrezygnowac
z ustawiania rozmiaru

trzeba sie zastanowic jak do tego podejsc od strony
painterow

i moze tym sie zajmiemy pozniej.

najpierw jednak skupimy sie na przywroceniu funkcjonowania
rysowania gestow, bo to zepsulismy nasza refaktoryzacja

no dobra, to juz wyglada na naprawione

to co dalej?


teraz bysmy chcieli stworzyc pop-upa

üìÅ ..
üìÑ file.grasp

co sie stanie jezeli wyrzucimy zawartosc pop-upa ze starego
prototypu?

ogolnie nie ma takiej mozliwosci, bo kazdy pop-up
ma jakis target.


ok, to teraz painter bedzie musial otrzymac nowe metody:




* 30.05.2023

udalo sie zrobic tak zeby Overload bylo Pane
- i ten klient terminalowy teraz nawet dziala,
  choc sa problemy z androidowym, a desktopowy
  to nawrt nie byl jeszcze testowany

i pomijajac kwestie przywrocenia dzialania
- co chcemy robic dalej?

na pewno chcielibysmy miec menu, takie
jak w kliencie javowym

musimy zatem odkopac nieco starego kodu

To by teraz jakos tak wygladalo

(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (Below
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)

no dobrze, w Javowym prototypie mielismy metode trySetSize,
i element Below mogl go sobie wywolac

I tutaj tez bysmy chcieli miec cos podobnego.

(define-interface PotentiallyResizable ()
  (try-set-width! width::real)::void
  (try-set-height! height::real)::void
  )

no dobra, ale teraz pojawia sie nam tutaj nowy aspekt,
mianowicie chcielibysmy, zeby wszystkie widgety byly
"Enchanted"

i wowczas bysmy:
1. zaimplementowali try-set-<size>! dla Button
2. zmienili czcionki na takie
   ktore wygladaja jak w starym kliencie javowym

tylko jeszcze pytanie, jak sprzac ze soba guziki
w taki sposob, zeby w kliencie terminalowym te guziki
wygladaly tak

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ‚îÇ New          ‚îÇ‚îÇ
‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ
‚îÇ‚îÇ Open...      ‚îÇ‚îÇ
‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ
‚îÇ‚îÇ Switch to... ‚îÇ‚îÇ
‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ
‚îÇ‚îÇ Save as...   ‚îÇ‚îÇ
‚îÇ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§‚îÇ
‚îÇ‚îÇ Close        ‚îÇ‚îÇ
‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

Zamiast

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ New          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Open...      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Switch to... ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Save as...   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Close        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


* 29.05.2023

zmiany, od ktorych zaczynamy obsluge plywajacych
okien:
- usuwamy move! z interfejsu Pane
- tworzymy klase Screen, zawierajaca:
  - overlay
  - dragginng
  - top-pane
  - metode move!
  - elementy overlay rowniez powinny stac sie
    Pane, natomiast Drag powinno byc klasa
    abstrakcyjna implementujaca Pane

no dobra, klase Screen juz mamy (choc bez podniety),
natomisdt pozostaja nam jeszcze takie rzeczy, jak:
- usunac move! z Pane
- spraeic, zeby Drag bylo Pane


no ale chwila

dlaczego chcemy zeby Drag bylo Pane?

to chyba bez sensu?

chcemy za to, zeby Overlay bylo Pane.



* 26.05.2023

plany na najblizszy czas to:
- przeniesc nowe cymesy tak zeby manifestowaly
  sie w kliencie graficznym

to sie moze udac nawet dzis. ale co dalej?

jeszcze bysmy chcieli moze zintegrowac
touch-event-processor z klientami pecetowymi
- ale tak naprawde chyba najlepiej to zrobic
  jak bedziemy mieli obsluzony second-press itp.,
  no bo jak inaczej to przetestujemy?

w takim razie wydaje sie, ze byc moze kolejnym
istotnym do zaimplementowania ficzerem jest
wyswietlanoe menu oraz otwieranie i zapisywanie
plikow


ale mozemy to potraktowac jako okazje do
przemyslenia jak to powinno wygladac

na razie mamy

New
Open...
Switch to...
Save as...
Close

i takue cos powinno sie rzeczywiscie pojawiac
na pustym dokumencie

ale do tego jeszcze:
Paste
History view/Document view

na wyrazeniu zas bysmy chcieli miec:
Copy
Cut
Paste (replace)

* 24.05.2023

male podsumowanie: udalo sie dodac do klienta
androidowego quote, quasiquote i unquote.

jutro bysmy sie jeszcze zajeli unquote-splicingiem
oraz cudzyslowami do stringa, a takze odpowiednim
kolorowaniem kreski oddzielajacej glowe od ogona,
a takze przeniesieniem tych zmian do klienta AWT


* 23.05.2023

no dobra, to dzisiaj bysmy wreszcie sie zajeli tymi
klientami graficznymi

czyli mamy do dodania 16 nowych funkcji,
o implementacjach raczej trywialnych

przede wszystkim jednak chcemy zaprojektowac wyglad
tych znaczkow, i moze przy tej okazji przeprojektowac
nawiasy

do tego dochodzi jeszcze taka mysl, zeby funkcje rysujace
dla quote'a i quasiquote'a sprawdzaly, czy elementem
wewnetrznym jest unquote, i w takich przypadkach rysowaly
sie ciasniej, niz w pozostalych

* 22.05.2023

dzis bysmy sie zajeli poprawka zachowania kursora
na quote'ach:
- jezeli "expression" to lista, to wtedy sie
  pod nia podszywamy
- natomiast w przeciwnym razie implementujemy
  schemat indeksacji [ 0 ]

Do tego dochodza rzeczy, o ktorych nie myslelismy,
czyli obsluga w ramach naszego systemu edycji
- i to chyba bysmy sprobowali zrobic przed implementacja
w klientach graficznych

no ale moze najpierw uporzadkujemy kwestie
kursora po zaczarowaniu wyrazenia

wydaje sie tez, ze mamy pewne problemy z unquote-splicing

ok, chyba je rowniez sie udalo naprawic.

No to co dalej?

teraz bysmy sie chyba zajeli klientami graficznymi.

albo ewentualnie obsluga cytowan w parserze.

* 20.05.2023

na pewno trzeba poprawic zachowanie kursora podczas
zaczarowywania wyrazenia, oraz zaimplementowac
podswietlanie markerow (tak jak to jest z nawiasami)

* 19.05.2023

mamy juz mniej wiecej zdefiniowane rozszerzenia
dla quote'ow. teraz:

- przetestujmy je na kliencie terminalowym
- dodajmy stosowne funkcje do klientow graficznych
- zintegrujmy te rozszerzenia z parserem

no ale najpierw trzeba dopiescic samego klienta
terminalowego, czyli:

- wyswietlanie kursora
- resize


do tego jeszcze bysmy chcieli dodac funkcje edycji:
- wcisniecie ` na nawiasie


* 18.05.2023

otoz mamy to.
teraz dalsze akcje:
- napisac rozszerzenie dla quote

  Na razie robimy to recznie, a potem moze
  cos sobie wyabstrahujemy.

wydaje sie, ze trzeba troche wyprostowac
zaleznosci w modulach

ok, to sie udalo

to terax chcemy dla tych swoich cycatow zaimplementowac:

  (part-at index::Index)::Indexable*

  (first-index)::Index
  (last-index)::Index

  (next-index index::Index)::Index
  (previous-index index::Index)::Index

  (index< a::Index b::Index)::boolean

  (draw! context::Cursor)::void
  (cursor-under* x::real y::real path::Cursor)::Cursor*

  (extent)::Extent


* 17.05.2023

to dzis moze bysmy zaimplementowali metody do quote'ow
w kliencie tekstowym, ale jeszcze bez rozszerzania
interfejsu Painter (albo na razie tylko w komentarzach)

* 16.05.2023

z jednej strony mozemy sie zajac tym event-processorem,
z drugiej - warto sie skupic na tych quote'ach
(co wydaje sie o tyle problematyczne, ze od razu
bysmy tez chcieli zrobic zmiany dla klientow graficznych)

No ale dopsz. Przywolajmy sobie rysowanie sekwencji:

tak wyglada metoda draw! w klasie cons:

  (define (draw! context::Cursor)
    ::void
    (let* ((inner (sequence-extent (this)))
	   (painter (the-painter))
	   (paren-width (painter:paren-width)))
      (painter:draw-box! (+ inner:width (* 2 paren-width))
			 inner:height
			 context)
      (with-translation (paren-width 0)
	  (draw-sequence! (this) context: context))))

moglibysmy zrobic taki enum:

(define-enum ParenType
  (Regular Quote Quasiquote Unquote UnquoteSplicing))

( quote x )
[0  1  234]


a jeszcze z innej beczki: chcielibysmy, zeby
long-press robil nam inwalidacje ekranu na Androidzie

no ale dobra, bysmy dodali takie metody do paintera:

-draw-quote-box!
-draw-quasiquote-box!
-draw-unquote-box!
-draw-unquote-splicing-box!

-draw-quote-mark!
-quote-mark-width

-draw-unquote-marks!
-unquote-mark-width
-draw-quasiquote-marks!
-quasiquote-mark-width
-draw-unquote-splicing-marks!
-unquote-splicing-mark-width

-quote-paren-width
-quasiquote-paren-width
-unquote-paren-width
-unquote-splicing-paren-width


* 15.05.2023

no to co teraz robimy:
wtorek - commitujemy to co mamy,
sroda - dodajemy touch event processor do klientow pctowych?
czwartek - operator "quote" w malarzu i parserze?

kolejny tydzien bysmy poswieili na quasiquote'y

nastepnie bysmy troche zmienili reprezentacje atomow,
dodali mozliwosc scrollowania ekranu i wczytywania plikow,
i juz od tego momentu bysmy probowali uzywac edytora
do edytowania niego samego

* 14.05.2023

no dobra, to na czym stoimy:
- mamy w miare chyba sprawny mechanizm rozszerzen
  (choc jeszcze nie wszedzie nalezycie podpiety)
- mamy touch event processor czekajacy na podpiecie
  do klientow pecetowych

i to sa takie drobniejsze rzeczy, ktorymi mozemy zajmowac
sie w miedzyczasie

natomiast tym, co nas ekscytuje nieco bardziej,
jest mechanizm cytowania

do tego trzeba:
- dodac mechanizm do paintera
- dodac rozszerzenie
- zmodyfikowac parser


natomiast samo rozszerzenie powinno z grubsza tak dzialac:
- sprawdzamy, czy nasz 'target' to lista. jezeli tak,
to renderujemy te liste ze specjalnymi nawiasami, a jezeli
nie, to renderujemy specjalne markery wokol elementu


zaczniemy od quote'a

no i trzeba pamietac, ze oprocz klienta terminaloaego
wypadaloby dodac te funkcjonalnosc w klientach graficznych,
wiec bedzie trzeba dodac odpowiednie funkcje rysujace

(define-object (quote target)::Extension

 (define (draw! context)::void
  (cond
    ((gnu.lists.LList? target)
     (draw-sequence! ze specjalnymi nawiasami)
     ...)
    (else
     (draw! ale najpierw narysuj prostokacik)
     ...)))

 (define (extent)::Extent
  (cond
    ((gnu.lists.LList? target)
     ;; rozmiar targetu + rozmiar nawiasow
     ...)
    (else
     ;; rozmiar markera + rozmiar targetu
     ...)))

 ;; i jeszcze inne metody
   )



* 13.05.2023

na razie niewiele udalo sie ustalic
(choc pewnie rzecz ma zwiazek ze status
barem)

na razie poprawilismy renderowanie
zaokraglonych prostokatow

poniewaz jednak w klientach graficznych te
napisy wygladaja dosc brzydkawo, trzeba bedzie
troche pokomplikowac malarza (ale to nic)

rowniez rysowanie linii w kliencie androidowym
powoduje swego rodzaju brzydkosc, chociaz
to pewnie szybko poprawimy


* 12.05.2023

dzis moze zaczniemy od tego przesuniecia

* 11.05.2023

rzeczy do wyjasnienia:
- dlaczego button w androidzie powoduje crash?
  - ok to juz wyjasnione (i naprawione)
- dlaczego klikanie na button nie dziala
  w klientach terminalowych?
- skad jest to przesuniecie

co wiecej, chcemy touch-event-processor podpiac
do klienta terminalowego i desktopowego
(najlepiej na asusie, tylko trzeba tam najpierw
postawic system, a zeby to sie udalo - trzeba
go uruchomic)

a kiedy to sie uda, zajmiemy sie tym quasiqouote'owaniem

normalnie 'x to (quote x)

(quote (quote x))

czyli tak:

(quote x)

jezeli x jest param to renderujemy ja
w specjalnych nawiasach


* 10.05.2023

plan z grubsza taki:
- poprawne renderowanie guzika w klientach graficznych
  (wymaga poprawek w malarzu)
- podpiecie zdarzen do rozszerzen
- podpiecie touch-event-processora do klientow pecetowych


Do tego bysmy chcieli zrobic rozszerzenie
"quote", ktore po prostu renderuje grubsze
nawiasy, albo

      ‚ññ ‚ñó
'x =>  x

      ‚ñó
'x =>  x

      ‚ññ    ‚ñó
'x =>  atom


‚ñº    ‚ñº
 atom

‚ó§    ‚ó•
 atom

‚ó•    ‚ó§
 atom



czyli tak: jezeli mamy (quote (quote ...))

* 07.05.2023

na razie bysmy tak zrobili, zeby guziki
sie dobrze wyswietlaly w klientach

trzeba tez cos wykombinowac zeby klikniecie
na atomy powodowalo wysuwanie klawiatury
(a na przyklad wcisniecie guzika tego nie powodowalo)



* 01.05.2023

teraz jakos bardziej siedzi w glowie system
obslugi zdarzen (dla kazdego klienta bedzie
trzeba zrobic osobno)

ale oprocz niego chcemy:
- mechanizm rozszerzen
- kwazi-kwotacje
- otwieranie i zapisywanie plikow
- dzielenie ekranu
- scrollowanie
- pozbycie sie bugow

  moze sie to uda osiagnac w kolejnym ufo

* 27.04.2023

no to teraz plan jest taki:
- najpierw analizujemy dzialanie systemu zdarzen
  na androidzie i ew w starej aplikacji
- nastepnie przenosimy ten model do klientow kawowych

a i jeszcze w miedzyczasie naprawiamy moze
renderowanie guzika w klientach graficznych?

* 26.04.2023

wydaje sie ze tab juz dziala (tylko trzeba jeszcze
potestowac na kliencie terminalowym), teraz zas
bysmy jeszcze sprobowali popodpinac te event handlery
w normalnych klientach (tak jak w primitive-terminal-client).

no dobra, a teraz bedzie jeszcze kilka uwag dotyczacych
obslugi inputu

mamy wszak trzy klienty, i wszystkie dzialaja
nieco inaczej


* 25.04.2023

ostatnich pare dni krecilo sie glownie wokol ELS,
w tym mojej wczorajszej prezentacji (ktorej odbior
byl zdecydowanie pozytywny)

teraz commity beda juz tylko we srode i w czwartek,
a pozniej przynajmniej tydzien przerwy

do tego czasu vysmy sprobowali zaimplementowac
te guziki w normalnych klientach

jest tez pare warpliwosci zwiazanych z reprezentacja
- bo mamy tylko jedna funkcje 'cons', choc tak naprawde
 bysmy chcieli miec dwie takie funkcje - pierwsza
do uzywania w ramach dokumentu, oraz druga do uzywania
wewnatrz aplikacji.

Rzecz jest jeszcze do przemyslenia, ale na pewno
trzeba to jakos bedzie uporzadkowac, przede wszystkim
ze wzgledu na pisanie rozszerzen.

No dobra, ale teraz mamy przed soba dwa cele:
- przetestowac zaczarowywanie i odczarowywanie
i spiac je z interfejsem (i przetestowac czy
guzik bedzie dzialal)
- zaimplementowac quasi-quotacje i te pe.

No dobra. Teoretycznie operacja  jest zaimplementowana,
tylko trzeba ja podpiac do interfejsu...

* 22.04.2023

wczoraj palcem nie kiwnelismy, to moze dzis
kiwniemy? (w samolocie?)

* 21.04.2023

To moze dzisiaj:
- dodamy enchant! i disenchant! do naszych operacji
  historycznych
- dodamy


* 20.04.2023

No dobra, czyli teraz tak:
- rozrywamy enchant/disenchant! na dwie osobne funkcje
- linkujemy te funkcje z operacjami historycznymi


* 19.04.2023

no to mamy problem.

problem pomiedzy przechodzeniem miedzy swiatem struktur,
a swiatem wartosci i z powrotem.

dotychczasowe rozwiazanie polegalo na tym, ze
mielismy mape, ktora przechowywala wyrazenie,
na podstawie ktorego zostalo wygenerowane
rozszerzenie.

ograniczeniem tego rozwiazania jest to, ze zmiany
w rozszerzeniu nie zostana uwzglednione po konwersji
z powrotem do listy

problem objawia sie np. przy wyrazeniach lambda,
ktorych po ewaluacji nie mozemy zserializowac

ale wydaje sie, ze wiekszym problemem jest brak
klarownosci umyslu.

Chodzi o to, ze z jednej strony mamy wyewaluowane struktury,
z drugiej - drzewa rozbioru skladniowego, a z trzeciej
- te same drzewa, ale jako edytowalne byty

do tej pory naszym jedynym zrodlem drzew bylo parsowanie,
ale teraz bedziemy jeszcze dodatkowo mieli:
- wyniki ewaluacji
- serializacje rozszerzen

I teraz pomysl jest taki, zeby to autor rozszerzenia byl
odpowiedzialny za jego serializacje.

Czyli w przypadku Button rzeczywiscie moglibysmy
zachowywac i przywracac oryginalna liste.

No dobra. Cos tam sobie wyjasnilismy,
a teraz pora przeniesc rozwiazanie do normalnych klientow.
To bedzie wymagalo:
1. rozbicia enchant-expression! na dwie operacje
2. dodania EnchantExpression i DisenchantExpression
   do historii
3. podpiecia tej nowej funkcji do inputu
   (w assets/init.scm?)

* 18.04.2023

plan na dzis/jutro:
- przetestowac 'construct'
- zrobic podmianke w extension i button
- zintegrowac rozszerzenia z docelowymi klientami?

A jak to sie uda, to bedziemy pisac implementacje
dla quote-ow - najpierw jako rozszerzenia, pozniej
do parsera


* 17.04.2023

no to co?

plan na dzis taki, ze refaktoryzujemy
enchant-expression! tak zeby disenchant!
bylo osobna operacja; podpinamy je
do historii i wywalamy origin, zastepujac
je uzyciem metody to-list.

No, ale tutaj pomysl jest taki, ze
bysmy mieli:

(define-property (construct type-name::symbol)::(maps (list) to: Struct)
  (lambda (_) #!null))

i define-type by dodatkowo robilo

(set! (constructor 'type)
  (lambda (properties)
    (let ((item (type)))
      (let init ((properties (cdr initializer)))
        (otherwise item
          (and-let* ((`(,key ,value . ,rest) properties))``
	    (slot-set! item (keyword->symbol key) value)
	    (init rest)))))))

a zamiastveval btsmy mieli

(define (construct struct-spec::list)::Struct
  ((constructor (car struct-spec)) (cdr struct-spec)))


a tu w niedzyczasie sie rodzi plan prezentacji
1. zamiast jednego duzego dema - duzo malych dem (i opowiesc)
2. programowanie jako srodek rozumienia
3.


* 16.04.2023

No to teraz plan jest taki, ze
dodajemy nowe metody do define-type:
- (fields transform::procedure)::list
- (as-list transform::procedure)::list

w praktyce wyszlo troche inaczej,
ale to niewazne

moglibysmy tez cos wykombinowac, zeby
nie alokowac kazdorazowo listy, tylko
zeby w zamian przechowywac zcache'owana
liste w ktorej tylko aktualizujemy pola
(za pomoca set-car!), bo w ten sposob
zachowamy spacje pomiedzy elementami

no ok, to tym sie tez zajmiemy,
i co dalej?

dalej wywalamy "origin" z (extensions)
i uzywamy to-list jako disenchant, natomiast
list->struct, a moze raczej list->extension
zamiast evala w przypadku enchanta.

No wlasnie, bo teraz chodzi o to, ze z list->struct
bedziemy mieli do czynienia tylko w sytuacjach,
gdy "extension" bedzie implementowalo Struct.

Z pewnoscia takie sytuacje beda typowe, ale
waznym wyjatkiem od tej reguly bedzie quote
i przyjaciele.

Oznacza to, ze bedziemy potrzebowac jakiejs
globalnej tablicy, ktora bedzie nam mapowala
symbole na funkcje tworzace.

ALe ale w (extension) takie cos jest juz zdefiniowane!

(define-mapping (extension keyword)
  (begin
    (WARN "no extension for "keyword)
    #f))

i jest uzywane np. przez Button o tak:

(set! (extension 'Button)
      (object (Extension)
	((create-from source::cons)::Enchanted
	 (try-catch
	  (or (as Button (eval source)) #!null)
	  (ex java.lang.Throwable
	      (WARN "Unable to create Button from "source": "
		    (java.lang.String:valueOf ex))
	      #!null)))))

No ok, i teraz zamiast (eval source) bedziemy
robili (list->struct source)?

No dobra, to sie nawet wydaje miec sens.

Natomiast dla quote'ow i innych zdefiniujemy sobie
po prostu jakis inny mechanizm (licze ze sie to wyjasni
w tym tygodniu)

Czyli jaki ma byc kolejny krok?

Teraz caly czas naszym celem jest wywalenie "origin"
z (extension). Ale z pewnoscia jak to zrobimy, to
nam sie rozlezie to wyrazenie.

Dlatego bysmy sobie wprowadzili cache'owanie
i update, i opracowali wariant Buttona, ktory
juz z "origin" nie bedzie korzystal.

Nastepnie bysmy to zintegrowali z trzema "prawdziwymi"
klientami (co byc moze bedzie wymagalo zmiany tylko
w jednym miejscu - tylko koniecznie trzeba pamietac
o uwzglednieniu historii), i napisali rozszerzenia
dla quote'a, quasiquote'a itd (co juz bedzie wymagac
zmian we wszystkich klientach, a w kazdym razie w ich
malarzach)

Jezeli sie to uda zrobic w ciagu tego tygodnia, to bedzie
arcy-zacnie.

* 15.04.2023

No dobra, to teraz mamy nowy plan:
chcemy aktywowaƒá mechanizm rozszerzen
dla guzika, tak jak w primitive-terminal-client.

powinnismy wszelako miec operacje
zaczarowywania i odczarowywania
na poziomie historii

No dobra, ale to tylko jeden aspekt.

w (extensions) mamy wlasciwosc origin,
uzywana przez enchant-expression.

chcielibysmy sie jej pozbyc, a w zamian
bysmy dodali metode to-s-expression
ktora by sie automatycznie generowala
dla struktur definiowanych przez
define-type.

Cos w stylu

(define-interface Structurizable ()
  (as-structure)::(either Atom List Text)
  (from-structure s::(either Atom List Text))::Structurizable)

(define (structure x)::(either Atom List Text)
  (match x
    (n::number
     (Atom (number->string n))
    (s::symbol
     (Atom (symbol->string s))
    (t::string
     (text t))
    (r::Structurizable
     (r:as-structure))
    (e::Element
     e)))


(as-structure conversion::(maps Object to: Object))::Object

* 14.04.2023

mamy jeszcze jakis blad z tym
komentarzem, ale na razie to sobie
odpuszczamy

no to co robimy?

dobrze by bylo sie zajac tymi
quasiquote'ami.

i tutaj plan jest taki:

- dodac wsparcie w parserze
- zintegrowac mechanizm rozszerzen

no dobra, co do parsera to
jezeli wczytamy ' ,@ , `, #' #,@ #, #`
to wywolujemy read rekurencyjnie,
po czym zwracamy odpowiednia liste
dwuelementowa

tyle ze zamiast listy powinnismy
raczej zwrocic rozszerzenie

i teraz: jak w ogole chcemy
te rozszerzenia definiowac?

(define-extension (quote item)
  ((draw! context::Cursor)::void
   (cond
     ((list? item)
      ;; zmien typ nawiasow,
      ;; wnetrze wyrenderuj normalnie
      )
     (else
      ;; wyrenderuj patyczek
      ;; przed atomem
      )))
  ((cursor-under* x y cursor)
   ...)
  ((first-index) #\')
  ((last-index) 0)
  ...)


* 13.04.2023

udalo sie zlokalizowac jeden blad
(gdy wykomentowujemy pierwszy element
listy), i teraz bysmy sie postarali
to naprawic

i moze jeszcze ten nasluch na serwerze
bysmy zrobili jako

./grasp-terminal debug-port: 12345

* 12.04.2023

Ale dzisiaj to juz na pewno zrobimy to
wykomentowywanie wyrazen, prawda?

no, to teraz tak:

do test-editor-opeations dodajemy
testy wykomentowywania wyrazen

udalo sie, ale mamy bledy, wiec
trzeba dla tych bledow napisac testy,
i nastepnie te testy naprawic.

na razie sprobujmy jednak uzupelnic
implementacje paintera dla klientow
graficznych


* 11.04.2023

Serwer gotowy i zintegrowany. Zidenyfikowalismy tez
miejsce w kodzie ktote nie tryka.

Z rzeczy do zrobienia na dzis mamy zatem:
- poprawic pejper na ELS
- dopracowac wykomentowywanie wyrazen srednikiem
- moze napisac testy?

Pod haslem 'niedaleka przyszlosc' wisi nad nami jeszcze
implementacja tgch niwych metod paintera w kliencie
graficznym, ale tym sie pewnie zajmiemy dopiero
jutro albo pojutrze.

Mamy natomiast - w zwiazku z przyszloscia nieco
odleglejsza - pewne zagwozdki odnosnie quasiquote'a.

Abstrahujac na razie od mechanizmu rozszerzen,
powinno to dzialac tak:
- jezeli renderujemy quasiquote'a po ktorym
  nastepuje wyrazeni w nawiasach, to zmieniamy nawiasy
  na podwojne
- od tej pory:
  - wszystkie wyrazenia w nawiasach renderujemy
    w podwojnych nawiasach
  - jezeli natrafimy na unquote i nawiasy,
    to renderujemy jako zwykle nawiasy,
    a zawartosc renderujemy normalnie
  - jezeli natrafimy na unquote-splicing
    i nawiasy, to renderujemy je jako zwykle
    nawiasy z wielokropkami, a zawartosc renderujemy
    normalnie
  - jezeli natrafimy na unquote bez nawiasow, to
    uzywamy 'malych haczykow na dole'
  - (analogicznie przy splicingu)

- jezeli renderujemy quasiquote'a po ktorym nastepuje
  cos innego, niz lista, to uzywamy do tego 'rozkow'

UWAGA, ZMIANA:

nie chcemy uzywac podowjnych nawiasow.

Zrobimy sobie aliasy dla `() ,() '() i ,@(), ale
tak poza tym nie bedziemy robic zadnych regul.

        0 1 2 3 4 5 6 7 8 9 A B C D E F
U+250x  ‚îÄ ‚îÅ ‚îÇ ‚îÉ ‚îÑ ‚îÖ ‚îÜ ‚îá ‚îà ‚îâ ‚îä ‚îã ‚îå ‚îç ‚îé ‚îè
U+251x 	‚îê ‚îë ‚îí ‚îì ‚îî ‚îï ‚îñ ‚îó ‚îò ‚îô ‚îö ‚îõ ‚îú ‚îù ‚îû ‚îü
U+252x 	‚î† ‚î° ‚î¢ ‚î£ ‚î§ ‚î• ‚î¶ ‚îß ‚î® ‚î© ‚î™ ‚î´ ‚î¨ ‚î≠ ‚îÆ ‚îØ
U+253x 	‚î∞ ‚î± ‚î≤ ‚î≥ ‚î¥ ‚îµ ‚î∂ ‚î∑ ‚î∏ ‚îπ ‚î∫ ‚îª ‚îº ‚îΩ ‚îæ ‚îø
U+254x 	‚ïÄ ‚ïÅ ‚ïÇ ‚ïÉ ‚ïÑ ‚ïÖ ‚ïÜ ‚ïá ‚ïà ‚ïâ ‚ïä ‚ïã ‚ïå ‚ïç ‚ïé ‚ïè
U+255x 	‚ïê ‚ïë ‚ïí ‚ïì ‚ïî ‚ïï ‚ïñ ‚ïó ‚ïò ‚ïô ‚ïö ‚ïõ ‚ïú ‚ïù ‚ïû ‚ïü
U+256x 	‚ï† ‚ï° ‚ï¢ ‚ï£ ‚ï§ ‚ï• ‚ï¶ ‚ïß ‚ï® ‚ï© ‚ï™ ‚ï´ ‚ï¨ ‚ï≠ ‚ïÆ ‚ïØ
U+257x 	‚ï∞ ‚ï± ‚ï≤ ‚ï≥ ‚ï¥ ‚ïµ ‚ï∂ ‚ï∑ ‚ï∏ ‚ïπ ‚ï∫ ‚ïª ‚ïº ‚ïΩ ‚ïæ ‚ïø

          ‚îè     ‚îì
'(...) => ‚îÉ ... ‚îÉ
          ‚îó     ‚îõ
          ‚îå     ‚îê
`(...) => ‚îÇ ... ‚îÇ
          ‚ïµ     ‚ïµ
       ‚îà‚îê     ‚îå‚îà
,@() => ‚îÇ ... ‚îÇ
        ‚îî     ‚îò
       ‚ï∑     ‚ï∑
,() => ‚îÇ ... ‚îÇ
       ‚îî     ‚îò
      ‚ñó
'x =>  x

      ‚îå ‚îê
`x => ‚ïµx‚ïµ


,@x => ‚îà‚îêx‚îå‚îà
        ‚îî ‚îò

,x =>‚ï∑x‚ï∑
     ‚îî ‚îò

`(f ,(+ x y) ,@(- y z))

‚ïì   ‚ï∑       ‚ï∑  ‚ï∑       ‚ï∑  ‚ïñ
‚ïë f ‚îÇ + x y ‚îÇ ‚îà‚î§ - y z ‚îú‚îà ‚ïë
‚ïô   ‚îî       ‚îò  ‚îî       ‚îò  ‚ïú

* 10.04.2023

Wyglada na to, ze laptop od Piotra zdechl (czy
w zasadzie zepsul mu sie wlacznik)

Mamy niedzialajacy kawalek kodu do komentowania,
ale nie mamy jak odpalac desktopowego klienta.

Stad pomysl na maly skok w bok: napiszemy sobie
serwer tcp, ktory bedzie implementowal interfejs
output-server-port

Czyli tak: wywolanie (tcp-outpt-server port::short)


no dobra, to mamy tak:
(current-output-port) ma typ gnu.kawa.io.BinaryOutPort
ktory rozszerza gnu.kawa.io.OutPort,
ktory rozszerza gnu.lists.PrintConsumer i implemenfuje Printable



* 09.04.2023

jezeli jestesmy na atomie albo na spacji,
to wcisniecie srednika powinno spowodowac
zakomentowanie wyrazenia

a jezeli jestesmy na komentarzu wyrazeniowym,
to powinnismy zamiast tego odkomentowac wyrazenie

* 08.04.2023

napisalismy test, ktory jednakowoz nie przechodzi.

problem chyba jest taki, ze procedura extract!
dla nie-komentarzy dodaje szerokosc wyrazenia
do spacji, natomiast procedura insert! dla
komentarzy juz tego nie robi

no dobra, mamy poprawke.

jutro bysmy sie zajeli
- integracja wykomentowywania z interfejsem
- implementacja trybu rysowania komentarzy
  w klientach graficznych

* 07.04.2023

no dobra. mamy hipoteze dotyczaca tego, jak powinna
dzialac nasza operacja. teraz zostaje nam jeszcze
przetestowanie tych operacji, dodanie ich do interfejsu,
i dodanie testu do operacji edycji

a do tego chcemy dodac nowe metody paintera
do grasp-desktop i grasp-android

a pozniej co?

- quote'y
- scrollowanie
- podzial ekranu
- ladowanie plikow

a pozniej co?

- ewaluacja
- rozszerzenia
- partykularne rozszerzenia
- sklep + wersja platna

* 06.04.2023

test wykazal, ze trzeba jeszcze troche dopiescic
insercje. i to bysmy zrobili, plus:
- dodali operacje historyczne
- zaimplementowali w kliencie desktopowym i androidowym


(define (f x y) z)

(the-expression at: '(5 3 1 1)) ===> y

(define (f x #;y) z)

(the-expression at: '(2 4 3 1 1)) ===> #;y


(define-type (CommentExpression at: Cursor following: int)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* ((`(,expression) (take! at: at from: document))
              (`(,tip . ,root) at)
	      (cursor (recons* following (- tip 1) root)))
     (insert! (ExpressionComment expression: expression)
              into: document at: cursor)
     cursor))
  ((inverse)::Edit
   (and-let* ((`(,tip . ,root) at))
     (UncommentExpression at: (recons* following (- tip 1) root)))))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* (((ExpressionComment expression: expression)
               (take! at: at from: document))
	      (`(,tip ,top . ,root) at))
     (insert! (cons expression '()) at: at into: document)
     (recons (+ top 1) root)))
  ((inverse)::Edit
   (and-let* ((`(,tip ,top . ,root) at))
     (CommentExpression at: (recons (+ top 1) root)
                        following: tip))))

* 05.04.2023

mamy niby napisany insert dla komentarzy,
ale trzeba jeszcze napisac testa.

* 04.04.2023

wyglada na to ze mamy awarie karty pamieci
i nasz projekt quote'ow wzial w leb

no to co teraz:
- insert!
- operacje historyczne
- integracja z interfejsem
- implementacje w edytorach graficznych

  ok to zacznijmy od analizy inserta

* 01.04.2023 (telefon)

Extract! juz jest zrobiony.
Teraz co jeszcze musimy zrobic:
- insert! dla komentarzy
- CommentExpression i UncommentExpression
- renderowanie wykomentowanych wyrazen
  - jako tekst
  - w terminalu (ciemniejszy kolor)


* 27.03.2023

pomysl jest taki, zeby zrefaktoeyzowac
funkcje "extract!" - tak zeby mogla zwracac
albo pare, albo separator, albo komentarz.

No, ale w tym celu musimy najpierw
przeanalizowac dotychczasowe dzialanie
tej funkcji, bo jest tak, ze rozne byly
zachowania w zaleznosci od tego,
ktory element zesmy ekstrahowali.

Rownolegle - poniewaz rysowanie gestow
zdaje sie pomagac w diagnozie - warto
poprawic klienta desktopowego

To moze przeanalizujmy architekture:

mamy screen-renderer, implementujacy
Paintera i bedacy JComponentem,
unterfejs InputListener agregujacy
rozne event handlery, oraz InputHandler,
rozszerzajacy JFrame i dostarczajacy
trywialnych implementacji.

Wreszcie jest window-screen, ktory rozszerza
InputHandler, dostarczajac nietrywialnych
implementacji handlerow tam gdzie trzeba.

I teraz plan jest taki, zeby window-screen
nie dziedziczyl po JFrame, tylko zebysmy
tworzyli JFrame, na ktorym bysmy
wywolywali setContentPane

No dobra. A co z tym naszym extractem?

* 27.03.2023 (komputer)

Master plan: window-screen powinien byc JComponentem,
run-in-AWT-window powinno tworzyc javax.swing.JFrame,
ktorego content-pane: to bedzie wlasnie window-screen.

Tylko kilka uwag:

- window-screen to nie jest dobra nazwa, i trzeba
wymyslic inna

- byc moze warto sie zastanowic nad scaleniem ze soba
tej klasy ze screen-rendererem

* 26.03.2023

(define/kw (fully-expanded? cursor::Cursor
             on: document := (the-document))::boolean
  (and-let* ((`(,tip . ,root) cursor)
             (target (cursor-ref document root)))
    (eq? target (part-at tip target))))

(define (cursor-trace document cursor)
  (match cursor
    ('() (cons document '()))
    (`(,tip . ,root)
     (and-let* ((trace (cursor-trace document tail))
                (`(,parent . ,elders) trace))
	(cons (part-at tip parent) trace)))))

no dobra. i teraz co?


* 25.03.2023

1. Wykomentowywanie wyrazen
dwie nowe operacje:

(define-type (CommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((preceding-cursor (cursor-retreat at document))
              (`(,item::Tile) (extract! at: at from: document)))
     (insert! (ExpressionComment expression: item)
              into: document at: preceding-cursor)
     preceding-cursor))
  ((inverse)::Edit
   (UncommentExpression at: ???)))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((
  ((inverse)::Edit
   (CommentExpression at: ???)))

Aczkolwiek problem jest taki, ze extract!
nie obsluguje komentarzy.

To pomysl jest teraz taki, zeby
- albo dodac obsluge komentarzy
  do 'extract!' (ktorej to funkcji
  jednak nie lubimw)
- albo po prostu po chamsku
  samemu wyciagnac z komentarza


A gdybysmy tak mieli napisac extract! drugi raz?

* 24.03.2023

zmiana rozmiaru dziala w miare OK.

to teraz skupilibysmy sie na takich
tematach:
- rysowanie kresek
- wykomentowywanie wyrazen
- poprawne dzialanie drag&drop na komentarzach?

Dobra, zacznijmy od tego rysowania kresek.

(define-object (Drawing stroke::Stroke)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    (stroke:add (Point x y)))

  (define (drop! x::real y::real vx::real vy::real)::void
    (the-overlay:removeIf (is _ Stroke?)))

  (the-overlay:add! stroke))

No, to rysowanie kresek juz jako tako dziala.
Wprawdzie jest jeszcze sporo do przemyslenia,
ale juz sie troche nie moge doczekac poniedzialkowego
commita.

No dobra, i co dalej?

Kolejna rzecz jaka mozemy robic, to:

- wykomentowywanie wyrazen
- poprawki w edycji komentarzy
- drag&drop na komentarzach


* 23.03.2023

Dzisiaj:
- naprawilibysmy buga zwiazanego ze zmiana rozmiaru
  pudelka w ktorym znajduje sie linia zakonczona
  komentarzem
- dodalibysmy mozliwosc rysowania kresek

Ale warto sie zastanowic czy nie lepiej
byloby ujednolicic reprezentacje spacji w taki
sposob, zeby nowa linia pojawiala sie explicite.

Do przemyslenia (choc tak po prawdzie to pewnie
raczej nie, bo wydaje sie, ze jestesmy dosc blisko
funkcjonujacego kodu)

Wyglada na to, ze bedzie trzeba troche popracowac :/

* 22.03.2023

Dzis bysmy sprobowali przemyslec co jest
do zrobienia w kontekscie poszczegolnych
klientow (terminalowego, desktopowego
i androidowego), a jaka kompetencje powinien
miec (pane), jezeli idzie o rysowanie gestow.

I takie pytanie: czy moglibysmy zaimplementowac
rysowanie gestu jako 'Drag'?

(define-object (DrawingGesture gesture::Gesture)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    ;; dodajemy Point do stroke'a
    ...)

  (define (drop! x::real y::real vx::real vy::real)::void
    ;; wywolujemy recognizer
    ...)

  (the-overlay:add! gesture))

* 21.03.2023

Przeanalizujmy obsluge gestow w grasp-android:

mamy globalny obiekt

(define the-stroke ::Stroke #!null)
(define the-gesture ::Gesture (Gesture))

oraz funkcje 'isShapeBeingDrawn'

(define (gesture-is-being-drawn?)::boolean
  (isnt the-stroke eq? #!null))

a do tego funkcje

(define (start-drawing-gesture!)::void
  (set! the-stroke (Stroke)))

(define (cancel-drawing-gesture!)::void
  (gesture:clear!)
  (set! the-stroke #!null))


no i dobrze. ale ciekawsze jest to, w jaki sposob
te funkcje sa wywolywane:

cancelDrawingShape jest wolany w:
-onDoubleTap
-onDown (gdy przycisnieto drugi palec
albo gdy onPress zwrocilo obiekt Drag)
-onMotion gdy wygenerowano DoublePress
-onUp jezeli udalo sie rozpoznac gest
-onSingleTap
-onLongPress

z kolei startDrawingShape jest uzywany
w onDown (jezeli nic innego sie nie wydarza)

wreszcie isShapeBeingDrawn jest:
- w onDown przy sprawdzaniu czy przycisnieto
  drugi palec i przy rozpoczynaniu rysowania
  ksztaltu
- w onMotion przy dodawaniu nowego odcinka
  do aktualnego stroke'a
- w onUp przed rozpoczeciem rysowania


natomiast finalizeStroke jest wywolywany przy
konczeniu rysowania

* 20.03.2023

Rysowanie gestow
ma dwojaki sens:
- czlowiek rysuje gesty
- program rysuje linie

No ale dobra
trzeba pomyslec
w jaki sposob chcemy
reprezentowac.

Teraz w (pane) mamy cos, co sie nazywa overlay,
i do czego mozemy wlozyc obiekty Drawable.

i teraz: chcielibysmy miec obiekt "Drawable",
ktory bylby dodawany do Overlay w momencie,
kiedy zaczynamy cos rysowac.

ale jak sie on bedzie nazywal?


* 19.03.2023

teraz to bysmy chcieli miec funkcje

(define 4pix-code
  (let ((4pix (mapping (4p::char)::int 0)))
(set! (4pix #\space) #b0000)
(set! (4pix #\‚ñò) #b0001)
(set! (4pix #\‚ñù) #b0010)
(set! (4pix #\‚ñÄ) #b0011)
(set! (4pix #\‚ññ) #b0100)
(set! (4pix #\‚ñå) #b0101)
(set! (4pix #\‚ñû) #b0110)
(set! (4pix #\‚ñõ) #b0111)
(set! (4pix #\‚ñó) #b1000)
(set! (4pix #\‚ñö) #b1001)
(set! (4pix #\‚ñê) #b1010)
(set! (4pix #\‚ñú) #b1011)
(set! (4pix #\‚ñÑ) #b1100)
(set! (4pix #\‚ñô) #b1101)
(set! (4pix #\‚ñü) #b1110)
(set! (4pix #\‚ñà) #b1111)
4pix))

(define 4pix ::char[]
  (char[]
  #\space
  #\‚ñò
  #\‚ñù
  #\‚ñÄ
  #\‚ññ
  #\‚ñå
  #\‚ñû
  #\‚ñõ
  #\‚ñó
  #\‚ñö
  #\‚ñê
  #\‚ñú
  #\‚ñÑ
  #\‚ñô
  #\‚ñü
  #\‚ñà
  ))

(define (4pix-set! x4::int y4::int)::void
  (let* ((x ::int (quotient x4 2))
         (h ::int (remainder x4 2))
         (y ::int (quotient y4 2))
	 (v ::int (remainder y4 2))
	 (c ::char (get y x))
	 (existing-code ::int (4pix-code c))
	 (mask ::int (arithmetic-shift 1 (+ (* 2 v) h)))
	 (new-code ::int (bitwise-ior existing-code mask))
	 (c* ::char (4pix new-code)))
    (put! c* y x)))


x^2 + y^2 = r^2

y^2 = r^2 - x^2

y = sqrt(r^2 - x^2)


(x0 - radius + i)


(define (draw-circle-4pix! x0::real y0::real radius::real)::void
  (let ((diameter ::int (ceiling (* 2 radius)))
        (r^2 (* radius radius)))
    (for i from 0 to diameter
      (let* ((dx ::real (- i radius))
             (dy :: real (sqrt (- r^2 (* x x))))
	     (x ::int (as int (round (+ x dx))))
	     (+y ::int (as int (round (+ y dy))))
	     (-y ::int (as int (round (- y dy)))))
        (4pix-set! x +y)
        (4pix-set! x -y)))))


* 18.03.2023


x1-x0   y1-y0
----- = -----
  m       n

y0 = ax0 + b
y1 = ax1 + b


(define (draw-line! x0::real y0::real x1::real y1::real)::void
  (let* ((x1-x0 ::real (- x1 x0))
         (y1-y0 ::real (- y1 y0))
	 (angle ::real (atan y1-y0 x1-x0)))
    (cond
      ((is -pi/4 <= angle <= pi/4) ;>>
       (let ((slope ::real (tan angle))
             (x0 ::int (round x0)))
         (for i from 0 to (as int (ceiling x1-x0))
	   (let ((x (+ x0 i))
	         (y (+ y0 (* slope i))))
             (put! #\‚ñà (as int (round y)) x)))))
      ((is pi/4 <= angle <= (* 3 pi/4)) ;>>
       (let ((slope ::real (/ (cos angle) (sin angle)))
             (y0 ::int (round y0)))
         (for j from 0 to (as int (ceiling y1-y0))
	   (let ((x (+ x0 (* slope i)))
	         (y (+ y0 i)))
	   (put! #\‚ñà y (as int (round x))))))
      (else
       (draw-line! x1 y1 x0 y0)))))


‚ñû‚ñö
‚ñö‚ñû

  ‚ñÑ
 ‚ñû ‚ñö
‚ñê   ‚ñå
 ‚ñö ‚ñû
  ‚ñÄ

‚ññ‚ñó ‚ñò‚ñù

 ‚ñó‚ñÄ
‚ñê   ‚ñå

  ‚ñÄ
* 17.03.2023 (telefon)

W ramach odpinki moze sprobujemy dodac do systemu
funkcjonalnosc rysowania gestow.

Ogolnie to musi wygladac tak, ze
jak zaczynamy rysowac gest, to dodajemy
'stroke' do overlaya, natomiast sam 'stroke'
to nic innego jak lista punktow.

Na pozor wydaje sie to latwe, ale pamietajmy
takze o tym, ze chcemy tez rysowac linie
w terminalu - i dlatego chcielibysmy dodac
mozliwosc rysowania linii do interfejsu Painter.

(mozna sie tez zastanowic nad uzyciem
w GRASP renderowania w stylu Figlet)

Oczywiscie rysowanie linii trzeba zaimplementowac
dwojako: w kliencie tekstowym i terminalowym.

W przypadku klienta terminalowego bedziemy
uzywac koloru, natomiast w przypadku klienta
tekstowego bysmy uzyli tego:

‚ñû‚ñÄ‚ñÄ‚ñÄ‚ñö
‚ñå    ‚ñå
‚ñö    ‚ñê
 ‚ñö   ‚ñû
  ‚ñö‚ñÑ‚ñû

‚ñõ‚ñú
‚ñô‚ñü ‚ñà

czyli dodajemy do paintera funkcje

(draw-line! x1::real y1::real x2::real y2::real)::void

i implementacje dla androida i awt (wolajace
pod spodem odpowiednie funkcje) oraz dla klienta
tekstowego

* 14.03.2023

Popsute klikniecia udalo sie naprawic, i powinny wyjsc
w jutrzejszej serii commitow.

Natomiast teraz chcemy sie zajac nastepujacymi rzeczami:
- dodawanie, usuwanie i edycja komentarzy blokowych
(poprzez wpisanie #| albo |# w kontekscie atomu - wowczas
powinnismy podzielic atom, np. ab#|cd powinno nam zrobic
dwa atomy ab cd, a miedzy nimi pusty komentarz blokowy)

tak naprawde to wcisniecie | powinno dzialac w taki sposob,
ze jezeli jestesmy na przedostatnim elemencie listy, to
sprawiamy, ze ta lista bedzie "dotted?". Jezeli natomiast
jestesmy na symbolu i po lewej albo prawej stronie
od kursora znajduje sie znak #, to go usuwamy
i wstawiamy komentarz blokowy (i przy okazji byc moze
rowniez rozbijamy atomy)

Wydaje sie, ze dodatkowo bedziemy chcieli zrobic
nowy rodzaj operacji edycji, ktory sobie nazwiemy
"EditSequence", o taki mniej wiecej

#+BEGIN_SRC scheme
(define-type (EditSequence operations:  (list-of Edit))
  ((apply! document)::Cursor
   (let ((result ::Cursor #!null))
     (for operation in operations
       (set! result (operation:apply! document)))
     result))
  ((inverse)::Edit
   (define (transform sequence inverted)
     (match sequence
       (`(,head::Edit . ,tail)
        (transform tail (cons (head:inverse) inverted)))
       ('()
        inverted)))
   (transform operations '())))
#+END_SRC

* 12.03.2023

Wyglada na to, ze biezaca implementacja komentarzy
blokowych popsula zupelnie detekcje klikniec.

* 09.03.2023

Do zrobienia mamy:
- usuwanie komentarzy
- chyba poprawki w inwersji dodawania komentarzy?
- renderowanie komentarzy blokowych
- edycja komentarzy blokowych
- dodawanie i usuwanie komentarzy blokowych

No dobrze, uznajmy komentarze liniowe za skonczone
(choc niewatpliwie trzeba sie jeszcze bedzie uporac
z bugami i roznymi corner case'ami, ktore jedak
na razie nie sa naszym priorytetem)

To teraz robimy komentarze blokowe.
Renderowanie musi tak przebiegac,
ze rysujemy prostokat, a wewnatrz
renderujemy tekst


* 08.03.2023

Wczoraj napisalismy funkcje do dodawania komentarzy
do spacji, oraz test dla niej.

Dzis bysmy sprobowali zintegrowac te funkcje z edytorem,
tak zeby wcisniecie srednika powodowalo dodanie komentarza
- aczkolwiek do tego bedzie jeszcze konieczne dodanie
operacji odwrotnej, tj. usuniecie komentarza

* 07.03.2023

Dzis bysmy sie zajeli edycja liniowych komentarzy.

W kolejce czeka jeszcze kilka pomniejszych rzeczy,
takich jak:
- naprawa polozen kursora na spacjach
- renderowanie lewej belki przy liniowych komentarzach
- renderowanie cudzyslowow przy stringach
- obsluga drag&dropa przy rysowaniu stringow i komentarzy

Ogolnie plan jest taki, ze najpierw skonczymy edycje
liniowych komentarzy, pozniej zrobimy pudelkowe
komentarze, a na koncu wyrazeniowe komentarze.

Kiedy to bedzie zrobione, zajmiemy sie quote'ami itd.
(oraz moze syntaxami itd.?),

a dalej bysmy zrobili to ladowanie i zapisywanie
i scrollowanie i dzielenie ekranu (ach jakie to bedzie
piekne)

i wowczas dalsze rzeczy bedziemy juz robic w samym
GRASPie! (jupi!)

No ale dobra. Teraz robimy edycje komentarzy.
Powinno to dzialac tak mniej wiecej:
1. jezeli jestesmy na spacji i wcisniemy ;,
to dodajemy do tej spacji nowy liniowy komentarz
(i odpowiednio przesuwamy kursor)
2. jezeli od tego miejsca nacisniemy na (pustym)
komentarzu backspace, to usuwamy komentarz
3. jezeli nacisniemy "delete" na poczatku komentarza,
to usuwamy caly komentarz
4. jezeli wciskamy na zwykly klawisz, to po prostu
   dopisujemy odpowiedni znak do komentarza
5. jezeli mielibysmy dopisac znak nowej linii,
   to dzielimy komentarz

To ostatnie bedzie najpewniej wymagalo zaimplementowania
interfejsu Textual w LineComment

Trzeba bedzie dodac nowe operacje:
(InsertComment content: TextualComment at: Cursor)

oraz

(RemoveComment content: TextualComment at: Cursor)

a takze

(CommentExpression at: Cursor)

oraz

(UncommentExpression at: Cursor)


* 06.03.2023

Dzisiaj musimy tak zmodyfikowac cursor-under* w Space,
zeby dawal poprawne indeksy podczas iterowania
(zeby klikanie na komentarze umieszczalo kursor
w odpowiednim miejscu)

Ponadto mozna by cos pokombinowac, zeby kursor
znajdujacy sie normalnie na spacji byl na takiej
samej wysokosci, co liniowy komentarz, jezeli
za nim znajduje sie liniowy komentarz.

No dobrze. To "Space::cursor-under*" powinien
sie zachowywac analogicznie do "advance!".

Wyglada na to, ze w pierwszym wierszu
komentarza wszystko dziala jak nalezy
- ale ze w drugim wierszu juz nie udaje
sie zlapac.

To sie chyba udalo jakos naprawic.

** Problem z generic-dispatch i subclassigniem

Przy okazji - problem, ktory pojawia sie, gdy mamy
"generic dispatch" oraz "subclassing" - i jest to
problem zasadniczo nierozwiazywalny:

(define-class <a> ())

(define-class <b> (<a>))

(define b (make <b>))

(define-class <c> (<a>))

(define c (make <c>))

(define-method (m (x <a>) (y <a>)) 'aa)
(define-method (m (x <b>) (y <a>)) 'ba)
(define-method (m (x <a>) (y <c>)) 'ac)

(m b c)

* 05.03.2023

W najblizszym czasie - w zwiazku z implementacja
komentarzy liniowych - bedziemy mieli do zrobienia
takie oto prace:
1. zeby klikanie na ekranie powodowalo umieszczenie
kursora w odpowiednim miejscu
2. zeby pisanie powodowalo dodawanie tekstu do komentarza
3. zeby komentarze mozna bylo przeciagac i upuszczac
4. zeby upuszczenie pudelka nad komentarzem powodowalo
   jego serializacje? (ale wtedy chyba to samo chcielibysmy
   dla stringow, c'nie?)


* 03.03.2023

Chyba z rysowaniem komentarzy udalo sie juz jakos dojsc
do ladu.

Ale teraz z kolei mamy inny problem:

kiedy kursor jest we wlasciwej czesci dokumentu, to nie dochodzi
do rysowania go.

* 02.03.2023

Wyglada na to, ze mamy problem z przypisywaniem indeksow
podczas rysowania spacji.

No to w takim razie przeanalizujmy sobie

Mamy 3 interesujace metody w Space:
1. draw!
2. advance!
3. cursor-under*

No i dobra, i teraz rozwazmy sobie te metode
draw!.

Ona robi tak, ze definiuje sobie wewnetrzna petle,
ktora "zjada" fragmenty spacji i sledzi wartosc "total".

I teraz tak: czym jest ow parametr "total"?

Pierwotna interpretacja byla taka, ze jest to
informacja o tym, ile spacji udalo sie juz przeskoczyc.

Mamy jednak przed soba kilka trundych kwestii:
- nie wiemy, czy poprzednia interpretacja w ogole byla dobra
- nie wiemy, jaka powinna byc nowa interpretacja

No, wezmy sobie

(Space fragments: (list 2 LC 2 LC))

Dziala to tak, ze najpierw total wynosi 0. Nastepnie:
- wywolujemy (advance-with-cursor! width) i dodajemy
width do total
- nastepnie mamy LC. Ono powinno byc na indeksie 3
kolejna 2


** a to takie tam bazgrolki:

Ô∏¥
Ô∏¥

‚åá
‚åá
‚åá

‚ï≠  ‚ïÆ
Ô∏¥ Ô∏¥
Ô∏¥ Ô∏¥
Ô∏¥ Ô∏¥
‚ï∞

‚∏æ        ‚ï≠         ‚ïÆ      ‚åá
‚∏æ define ‚îÜ map f l ‚îÜ      ‚åá
‚∏æ        ‚ï∞         ‚ïØ      ‚åá
‚∏æ ‚∏æ                     ‚ïÆ ‚åá
‚∏æ ‚∏æ match l             ‚îÜ ‚åá
‚∏æ ‚∏æ                     ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚îè  ‚îì ‚îè  ‚îì ‚ïÆ       ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚îá  ‚îá ‚îá  ‚îã ‚îÜ       ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚îó  ‚îõ ‚îó  ‚îõ ‚ïØ       ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚ïì      ‚ï•      ‚ïñ ‚ïÆ ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚îã head ‚îã tail ‚îã ‚îÜ ‚îÜ ‚åá
‚∏æ ‚∏æ ‚∏æ ‚ïô      ^      ‚ïú ‚ïØ ‚ïØ ‚åá


‚∏æ   ‚åá
‚∏æ   ‚åá
‚∏æ   ‚åá


‚è≠ ‚èÆ ‚èØ
‚è¥‚èµ‚è∂‚è∑‚è∏‚èπ‚è∫

* 01.03.2023

Wczoraj nie udalo sie osiagnac zbyt wiele - ale mimo
wszystko cos sie udalo!

Dzis zajelibysmy sie pisaniem staromodnych testow
dla "space-fragment-index", "delete-space-fragment!",
"Space:last-index", oraz zaimplementowalibysmy
w LineComment interfejs Textual
(ogolnie chcielibysmy zeby BlockComment takze
obslugiwal ten interfejs - ale ExpressionComment
juz niekoniecznie)

No ale dobra: rzecz ma sie tak, ze:
- wystapienie LineComment powodje pojawienie
  sie nowej linii (czyli tak jak pojawienie sie
  dwoch liczb po sobie)
- ale wystapienie BlockComment czy ExpressionComment
  juz niekoniecznie

Ale teraz jak to ogarnac?

Mamy takie operacje:
- rysowanie
- mierzenie
- klikanie

Poniewaz na razie rzecz wyglada nieco kiepskawo
jezeli idzie o diagnostyke, to zaimplementujemy
renderowanie komentarzy w kliencie desktopowym.

* 28.02.2023

Wczoraj z grubsza sie udalo zaimplementowac renderowanie
w kliencie tekstowym i terminalowym, ale nie mamy jeszcze
obslugi klikania, i strzalki w lewo i prawo tez jeszcze
nie calkiem dzialaja.

Dlatego dzis moze sprobowalibysmy sie zajac tymi dwiema
kwestiami.

* 27.02.2023

Do rozdzielenia juz doszlo, i wyglada na to,
ze niczego to nie psuje.

Teraz mamy dwa najistotniejsze watki:
1. zaimplementowac min-box-height na Androidzie
2. sprobowac dodac slowo kluczowe 'default
do domyslnych interfejsow, i usunac metode
"advance!" z implementacji Tile.

A w dalszej kolejnosci sprobowalibysmy pojsc
taka droga:
1. zaimplementowac komentarze liniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
2. zaimplementowac komentarze blokowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
3. zaimplementowac komentarze wyrazeniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
4. rozwazyc uzycie mechanizmu rozszerzen
  do wyswietlania quote, quasiquote, unquote, unquote-splicing
5. wprowadzic obsluge quote, quasiquote, unquote,
  unquote-splicing do parsera

No dobra, czyli teraz: komentarze liniowe dla klienta
terminalowego (i textowego)

To zaczynamy od tekstowego.
Bedzie trzeba dodac testy jednostkowe,
natomiast w przypadku terminalowego - jeszcze
ustawic kolory odpowiednio.

No dobra. Implementacja komentarzy musi sie skladac
z nastepujacych metod:
1. draw!
2. extent
3. cursor-under

* 24.02.2023

Teraz pomysl jest taki, ze poniewaz zakladamy,
ze linie skladajace sie tylko z komentarzy liniowych
moglibysmy ze soba scalac, moglibysmy rozdzielic
parametr "min-line-height" na "min-box-height"
i "min-line-height"

Gdzie jest uzywany min-line-height?

- W (extent '())
- w (empty-space-extent)
- przy inicjalizacji "traversal" jako max-line-height
  w traverse
- przy inicjalizacji obiektu Traversal w Space:extent
- w funkcji resize! do zmiany rozmiaru pudelka
- w metodzie new-line! obiektu Traversal
- w metodzie atom-extent w CharPainterze


* 23.02.2023

bysmy moze zaczeli od zaimplementowania
draw-line-comment! i draw-box-comment!
w painterze (tzn. w TextPainterze,
TerminalPainterze, screen-rendererze,
a w pozniejszym czasie rowniez
w androidowym View).

Dla TextPainter bysmy tylko robili

dla TerminalPainter bysmy tez dodali
troche koloru.

‚îÇ jeden srednik
‚îÉ dwa sredniki
‚î£ trzy sredniki
‚î£‚îÅ cztery sredniki
‚î£‚îÅ‚îÅ piec srednikow

Wreszcie dla screen-renderera - i docelowo
dla Androida tez - bysmy wybrali jakas
zwariowana czczionke

Jezeli idzie o komentarze pudelkowe,
to bysmy je tak rysowali:

‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò

Lispiarze maja ogolnie taka konwencje, ze
;;; Heading
;;;; subheading
;;;;; subsubheading

No dobra, ale pozostaje nam jeszcze kwestia
tego, ze chcielibysmy, zeby komentarze liniowe
byly jedna linia pod druga, tzn. zeby nie bylo
miedzy nimi takiego duzego odstepu, jak w przypadku
atomow

* 22.02.2023

Wydaje sie, ze przynajmniej pozornie:
- dodanie rysowania do komentarzy bedzie
raczej proste
- dodanie "cursor-under*" wymaga nieco myslenia
- dodanie 'advance!' tez powinno byc raczej latwe

No to zastanowmy sie nad tym "cursor-under*"

Mamy sobie kopie obiektu traverse.
Funkcja "cursor-under" odejmuje t:left i t:top
od otrzymanych wartosci left i top.

Ale z jakichs wzgledow implementacja cursor-under*
w Space przywraca rame odniesienia dla danego
obiektu Traverse.

Ogolnie rzecz biorac to ma sens o tyle, ze
spacje nie sa "foremne" i moga rozciagac sie
na wiele linii.

No ale dobra. W przypadku spacji transformujemy
wspolrzedne z powrotem do ukladu wspolrzednych
obiektu (the-traverse).

To teraz zamysl jest taki:
1. implementujemy metody draw!, cursor-under* oraz advance!
   dla wszystkich trzech odmian komentarzy
2. integrujemy to sobie w obiekcie space
3. wszystko hula i sie cieszymy

No dobrze, ale mamy tak:

|---------------+--------------------+------------------------+--------------------------|
| metoda        | LineComment        | BlockComment           | ExpressionComment        |
|---------------+--------------------+------------------------+--------------------------|
| draw!         | rysujemy           | rysujemy               | najpierw rysujemy        |
|               | jakis znacznik     | pudelko wewnatrz       | spacje (mozemy sobie     |
|               | i renderujemy      | ktorego renderujemy    | zalozyc ze sa zerowe)    |
|               | tekst (ale trzeba  | tekst (trzeba pomyslec | a po nich wyrazenie      |
|               | pomyslec o kolorze | o kolorze i kroju      | - ale trzeba w jakis     |
|               | i kroju czcionki)  | czcionki)              | sposob zmienic tryb      |
|---------------+--------------------+------------------------+--------------------------|
| cursor-under* |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|
| advance!      | normalnie          | normalnie              | najpierw spaces:advance! |
|               |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|


Trzeba przemyslec jakie zmiany by nalezalo wprowadzic do paintera.

Moglibysmy po prostu dodac:

enter-comment-drawing-mode!
exit-comment-drawing-mode!

A co z cytowaniem?

increase-quotation-level!
decrease-quotation-level!

increase-quasiquotation-level!
decrease-quasiquotation-level!

No i jeszcze co ze zwyklymi komentarzami?

draw-line-comment!
draw-block-comment!

line-comment-extent
block-comment-extent


‚ï≠        ‚ï≠         ‚ïÆ      ‚ïÆ
‚îÇ define ‚îÇ map f l ‚îÇ      ‚îÇ
‚îÇ        ‚ï∞         ‚ïØ      ‚îÇ
‚îÇ ‚ï≠                     ‚ïÆ ‚îÇ
‚îÇ ‚îÇ match l             ‚îÇ ‚îÇ
‚îÇ ‚îÇ                     ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï≠ ‚îè  ‚îì ‚îè  ‚îì ‚ïÆ       ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚îÉ  ‚îÉ ‚îÉ  ‚îÉ ‚îÇ       ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï∞ ‚îó  ‚îõ ‚îó  ‚îõ ‚ïØ       ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï≠ ‚ïì      ‚ï•      ‚ïñ ‚ïÆ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚ïë head ‚ïë tail ‚ïë ‚îÇ ‚îÇ ‚îÇ
‚ï∞ ‚ï∞ ‚ï∞ ‚ïô      ^      ‚ïú ‚ïØ ‚ïØ ‚ïØ


‚ï≠        ‚ï≠         ‚ïÆ      ‚ïÆ
‚îÜ define ‚îÜ map f l ‚îÜ      ‚îä
‚îÜ        ‚ï∞         ‚ïØ      ‚îä
‚îÜ ‚ï≠                     ‚ïÆ ‚îä
‚îÜ ‚îÜ match l             ‚îÜ ‚îä
‚îÜ ‚îÜ                     ‚îÜ ‚îä
‚îÜ ‚îÜ ‚ï≠ ‚îè  ‚îì ‚îè  ‚îì ‚ïÆ       ‚îÜ ‚îä
‚îÜ ‚îÜ ‚îÜ ‚îá  ‚îá ‚îá  ‚îã ‚îÜ       ‚îÜ ‚îä
‚îÜ ‚îÜ ‚ï∞ ‚îó  ‚îõ ‚îó  ‚îõ ‚ïØ       ‚îÜ ‚îä
‚îÜ ‚îÜ ‚ï≠ ‚ïì      ‚ï•      ‚ïñ ‚ïÆ ‚îÜ ‚îä
‚îÜ ‚îÜ ‚îÜ ‚îã head ‚îã tail ‚îã ‚îÜ ‚îÜ ‚îä
‚ï∞ ‚ï∞ ‚ï∞ ‚ïô      ^      ‚ïú ‚ïØ ‚ïØ ‚ïØ




* 21.02.2023

Dzis bysmy sie zajeli tym, zeby komentarze byly uwzgledniane
przy renderowaniu, rozmiaru wyliczaniu i myszki klikaniu.

I to wyglada tak, ze mamy sobie funkcje "traverse",
ktora wywoluje naprzemiennie zadana akcje oraz
metode advance! na obiekcie traversal.


W przypadku rysowania mamy item:draw!,
dla mapowania kursora mamy item:cursor-under*
natomiast przy wyliczaniu 'extent' nie mamy
zadnej akcji, ale mamy okreslona funkcje
zwracajaca.

I teraz: tutaj nic nie bedziemy zmieniac.

Musimy tylko zaktualizowac metody wewnatrz
Space:
- draw!
- cursor-under*
- advance!

* 20.02.2023

No dobra, wydaje sie, ze edycje z klawiatury mamy
jakos tam zaimplementowana.

Moze finalnie bedzie trzeba wprowadzic jakas
dywersyfikacje dla delete-forward! i delete-backward!
(zeby kursor lepiej sie zachowywal)

No, ale teraz zajelibysmy sie juz innymi sprawami:
- po pierwsze, renderowaniem komentarzy (i to az w trzech
smakach) oraz nawigowaniem po komentarzach, edycja
komentarzy, ... (czyli mowiac krotko - edycja komentarzy)

- po drugie, obsluga kawowych rozszerzen skladniowych,
tak zebysmy mogli parsowac zrodla GRASP,
a przy okazji zajelibysmy sie obsluga rozszerzen
jako takich, tak zeby moc wyswietlac quote'y,
unquote'y i quasiquote'y, a takze - skoro to juz jest
w jakiejs formie - to moze nasz guzik?

- po trzecie, bysmy wreszcie zrobili to otwieranie
i zapisywanie plikow, scrollowanie widokow oraz
podzial ekranu

- a po czwarte - przywrocilibysmy podsystem gestow

Pozostaje jeszcze kwestia naszego pejperu,
do ktorego chcielibysmy dopisac informacje o tym,
jak ma byc zaprojektowany system gestow,
oraz screenow z rysowania gestow.

No ale tak:
do interfejsu Painter dolozymy metody
-quasiquote!
-unquote!
-quote!
albo cos w tym rodzaju

Chodziloby o to, ze:
- teksty i nawiasy ktore nie sa owiniete w quote'a
  ani unquote-a rysujemy normalnie
- teksty i nawiasy owiniete w jednego quote'a rysujemy
  pogrubione
- teksty i nawiasy owiniete w jednego unquote'a
  rysujemy kursywa

Czy cos. Jakos to sprobujemy pomyslec.

Na razie jednak te komentarze.

Problem jest taki, ze:
- LineComment i BlockComment wymagaja (text)
- ExpressionComment wymaga (space)
- (text) wymaga (space)

Wydaje sie zatem ze moze rzeczywiscie
bedzie trzeba utworzyc jakis interfejs
ktory bedzie w (space), natomiast same
implementacje umiescimy gdzie indziej
(moze w (text) i (primitive))

Natomiast metody, jakich bedziemy potrzebowac,
to:
- print


OK, na razie udalo sie wyodrebnic modul z komentarzami.

I co chcemy dalej?

No, dalej to z pewnoscia chcemy wyswietlac
te komentarze, uwzgledniac je przy wyliczaniu
rozmiarow i przy klikaniu kursorem

Co wiecej: w kliencie terminalowym chcielibysmy
wyswietlac komentarze w ciemniejszym kolorze,
zas w klientach graficznych uzyc do tego celu
jakiejs smiesznej czcionki.

I moze tym bysmy jutro sie zajeli, a pozniej
dodali do operacji edycji mozliwosc odkomentowywania
i zakomentowywania wyrazen oraz dodawania blokow
komentarzy i zakomentowywania linii


* 18.02.2023

*bold*
/italic/

‚ï≠        ‚ï≠         ‚ïÆ                                   ‚ïÆ
‚îÇ define ‚îÇ map f l ‚îÇ                                   ‚îÇ
‚îÇ        ‚ï∞         ‚ïØ                                   ‚îÇ
‚îÇ   ‚ï≠                                                ‚ïÆ ‚îÇ
‚îÇ   ‚îÇ march l                                        ‚îÇ ‚îÇ
‚îÇ   ‚îÇ                                                ‚îÇ ‚îÇ
‚îÇ   ‚îÇ    ‚ï≠ ‚óπ‚ï≠    ‚ï∑    ‚ïÆ ‚óπ‚ï≠  ‚ï≠     ‚ïÆ  ‚ï≠         ‚ïÆ ‚ïÆ ‚ïÆ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ  ‚îÇ  h ‚îÇ  t ‚îÇ  ‚îÇ  ‚îÇ f h ‚îÇ ‚óø‚îÇ map f l ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ    ‚ï∞  ‚ï∞ ‚óø  ‚ïµ ‚óø  ‚ïØ  ‚ï∞ ‚óø‚ï∞     ‚ïØ ‚óã‚ï∞         ‚ïØ ‚ïØ ‚ïØ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ    ‚ï≠ ‚óª‚ï≠  ‚ïÆ        ‚óª‚ï≠  ‚ïÆ ‚ïÆ                      ‚îÇ ‚îÇ
‚îÇ   ‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ ‚îÇ                      ‚îÇ ‚îÇ
‚ï∞   ‚ï∞    ‚ï∞  ‚ï∞  ‚ïØ         ‚ï∞  ‚ïØ ‚ïØ                      ‚ïØ ‚ïØ


‚ï≠        ‚ï≠         ‚ïÆ                  ‚ïÆ
‚îÇ define ‚îÇ map f l ‚îÇ                  ‚îÇ
‚îÇ        ‚ï∞         ‚ïØ                  ‚îÇ
‚îÇ ‚ï≠                                 ‚ïÆ ‚îÇ
‚îÇ ‚îÇ match l                         ‚îÇ ‚îÇ
‚îÇ ‚îÇ                                 ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï≠ ‚îè      ‚îì ‚îè  ‚îì ‚ïÆ               ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚îÉ      ‚îÉ ‚îÉ  ‚îÉ ‚îÇ               ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï∞ ‚îó      ‚îõ ‚îó| ‚îõ ‚ïØ               ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚ï≠ ‚ïì      ‚ïñ ‚ïì ‚ï≠        ‚ïÆ     ‚ïñ ‚ïÆ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚ïë head ‚ïë ‚ïë ‚îÇ f head ‚îÇ     ‚ïë ‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚ïë ____ ‚ïë ‚ïë ‚ï∞_______ ‚ïØ____ ‚ïë ‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚ïë      ‚ïë ‚ïë ‚ï≠            ‚ïÆ ‚ïë ‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îÇ ‚ïë tail ‚ïë ‚ïë ‚îÇ map f tail ‚îÇ ‚ïë ‚îÇ ‚îÇ ‚îÇ
‚ï∞ ‚ï∞ ‚ï∞ ‚ïô      ‚ïú ‚ïô ‚ï∞            ‚ïØ ‚ïú ‚ïØ ‚ïØ ‚ïØ

‚ãÆ

‚ó¥
‚ñ¥‚óπ‚óã
‚ñæ
‚ñ≤
‚ñº

‚ñÆ‚óÄ‚óÄ  ‚ñÆ‚óÄ  ‚ñ∂/‚ñÆ‚ñÆ  ‚ñ∂‚ñÆ  ‚ñ∂‚ñ∂‚ñÆ

Pomalu sobie pomysliwamy
zeby quote i quasiquote implementowac
jako rozszerzenia (tyle ze musialyby byc
dostepne i wstawiane podczas parsowania)

* 17.02.2023

Wiele bledow udalo sie wczoraj naprawic, ale na pewno
sa tez takie, ktorych nie udalo sie znalezc ani obsluzyc.

Co nam teraz pozostaje:
- zrobmy tego delete-forward!
- poprawmy parser tak, zeby zamiast '() wstawial
  (empty) - tam gdzie powinien

To sa jednak rzeczy do scommitowania w kolejnym tygodniu
(choc zrealizowac je mozemy juz dzis)

Natomiast w weekend bysmy sie zajeli uzupelnieniem
ELSowego pejpera o referencje i kody CCS (na pewno
trzeba tez dodac medc.mark.dev i ewentualnie Bochser
oraz ten drugi GRASP)

OK, czyli moze na poczatku przyszlego tygodnia by sie
udalo miec delete-character! i tematyke edycji z grubsza
zamknieta (modulo ewentualne bugi)

Natomiast w dalszej kolejnosci mamy:
- obsluge komentarzy
- obsluge specjalnej skladni
- otwieranie i zamykanie plikow
- scrollowanie ekranu
- dzielenie ekranu

Zakladamy, ze to minimum do ELS (choc oczywiscie
mozemy sie pomylic), a jesli tak, to moze sie jeszcze
uda:

- mechanizm rozszerzen (we wszystkich klientach)
- rozszerzenie Button
- obsluga gestow (glownie a Androidzie, ale wszedzie
  indziej czemu nie?)

Natomiast celowalibysmy w to, zeby te funkcjonalnosci
byly juz implementowane w samym GRASPie.

* 16.02.2023

Ostatni przypadek testowy wykazal problem z robieniem "undo!"
merge'a, wiec to nim bysmy sie dzis zajeli.

Poza tym sprobowalibysmy przetestowac operacje na tekscie,
a jezeli czas pozwoli, to rowniez bysmy sprobowali
zrobic delete-backward!

OK, z tym merge'owaniem to sprawa wydaje sie nieco grubsza,
bo wyglada na to, ze operacja inverse nie dziala prawidlowo

Byc moze jednak bedzie to okazja do tego, zeby usunac
pole "document" z wiekszosci operacji edycji.

Ale bedzie trzeba albo dodac dodatkowe pole do

(SplitElement with: Space
              at: Cursor := (the-cursor)
	      in: pair := (the-document))

badz

(MergeElements removing: Space
               at: Cursor := (the-cursor)
               in: pair := (the-document))

albo moze tak:

(SplitElement with: Space at: Cursor)
(MergeElements removing: Space after: Cursor)

tak zeby

(inverse (MergeElements removing: Space after: Cursor))
= (SplitElement at: Cursor with: space)


* 15.02.2023

Mamy zrobione wstawianie znakow w atomy
i to jako tako dziala.

Ale duzo rzeczy jeszcze nie dziala, wiec
plan jest taki, ze:

- chcemy popisac troche testow dla funkcjonalnosci,
ktora mamy, i dla tej, ktorej jeszcze nie mamy

- zrobic scalanie historii kasowania znaku
  (analogicznie do scalania historii dodawania
  znaku)

- oraz naturalnie zaimplementowac
  delete-forward!

Commity moga byc robione dopiero dzis i jutro,
a nastepny w niedziele, dlatego byloby super
zamknac do jutra kwestie zwiazane z edycja.

* 13.02.2023

Wczoraj udalo sie zrealizowac (1). Dzisiaj
bysmy sie sprobowali zajac (2).

Ale trzeba ustalic nieco szczegolow, bo
zasadniczo chcemy, zeby kursor zachowywal
sie poprawnie, tzn. zeby operacja "redo!"
po wykonaniu "undo!" dzialala tak jak wczesniej.

Ale czy rzeczywiscie musimy sie tym martwic?
Operacje zapamietuja sobie przeciez polozenie
kursora, na ktorym operuja.

No dobra, spojrzmy zatem na [[analiza-edycji]] (28.01.2023)

* 12.02.2023

Na razie napisalismy wiekszosc pejpera - zostaly
nam jeszcze tylko referencje i kategoryzacje.

Natomiast teraz chcemy:
1. wyjasnic dlaczego jak dodajemy [] do "toplevelu",
to kursor jest zle pozycjonowany

2. zaimplementowac delete-backward! z obsluga historii

3. zaimplementowac delete-forward!?


* 09.02.2023

Wczoraj udalo sie poprawic blad w historii. Natomias
wczorajsze cele zasadniczo pozostaja w mocy, ale
do tego dochodzi jeszcze poprawienie edycji stringow.

* 08.02.2023

Dzisiaj na pewno chcemy przebadac i naprawic system
"undo!", i jakby sie udalo, to takze zaimplementowac
delete-backward! i zastanowic sie, co zrobic z
delete-forward!.

Mozna tez juz pomalu myslec o zgloszeniu na ELS.

* 07.02.2023

Teraz rzeczy do zrobienia:
- optymalizacja historii: chcemy scalac ze soba operacje
InsertCharacter o ile naleza do tej samej klasy
(czyli dodawanie spacji albo dodawanie nie-spacji)
no i oczywiscie spelnione sa warunki ciaglosci kursora.

To jedna rzecz.

Druga rzecz, to chcemy przetestowac czy operacje
dzielenia i scalania atomu dobrze dzialaja.

Trzecia rzecz wreszcie, to chcemy zaimplementowac
operacje kasowania.

* 06.02.2023

Mamy mala zagwozdke dotyczaca tego, w jaki sposob reprezentowac
usuwanie znaku w sytuacji, gdy robimy delete-forward! - ale
to na szczescie jeszcze nie jest palaca kwestia.

No dobra, dzis zajelibysmy sie tym:
- jezeli jestesmy na granicy atomu (lewej albo prawej)
  i wstawiamy bialy znak, to InsertCharacter powinien
  dotyczyc nie tego atomu, tylko graniczacej spacji
- Space powinno implementowac Textual
- jezeli wstawiamy bialy znak do srodka atomu, to powinnismy
  wygenerowac operacje Split, natomiast jezeli kasujemy
  spacje z wnetrza atomu, to powinnismy wygenerowac operacje
  Join

I taki oto jest plan na dzis.

No i OK. I teraz mamy takie cus:

(define-interface Textual ()
  (insert-char! c::char index::int)::void
  (delete-char! index::int)::char
  (char-ref index::int)::char
  (truncate! length::int)::void
  (subpart start::int)::Textual
  (text-length)::int
  )

Natomiast po stronie spacji to mamy metody:
- insert-space!
- insert-break!
- delete-space!

oraz funkcje
- insert-space!
- insert-break!
- insert-whitespace!
- delete-space!
- join-spaces!
- split-space!

Dobrze by bylo, gdybysmy przynajmniej pojeciowo
sprobowali sobie zmapowac, czy tez wypowiedziec
relacje, pomiedzy join-spaces! oraz split-space!,
a metodami subpart oraz truncate! interfejsu
Textual.

Otoz: subpart i truncate! sa uzywane w funkcji
insert! w przypadku dzielenia atomu.

Czyli teoretycznie funkcje "split-space!" moglibysmy
zaimplementowac analogicznie.

Ale jednak pomysl mamy duzo lepszy - usunmy
funkcje subpart i truncate, i zamiast nich
stworzmy metode split!

OK, to mamy:
- metode split! zamiast truncate! i subpart w Textual
- Space jako instancje Textual


* 04.02.2023

Wczoraj udalo sie wprowadzic InsertCharacter i RemoveCharacter
- tzn dodawanie znakow do obiektow Textual - ale koszt tego
przedsiewziecia byl taki, ze teraz mamy zepsuta obsluge spacji.

Wydaje sie tez, ze chcielibysmy:
- uzywac nowej metody (cursor) do wyliczania polozenia
kursora
- usunac reczne manipulacje kursorem z kodu
- moze bysmy zrobili tak, ze po prostu funkcja apply!
bedzie zwracala kursor, i usunelibysmy metode
(cursor)?


* 03.02.2023

wczorajszy plan o refaktoryzacji "Extract" pozostaje w mocy.
Ale do tego dochodzi jeszcze kilka pomyslow:

- na razie wydaje sie, ze probujemy zrobic takie cos:
  edycja: wcisniecie klawisza -> dispatching -> dodanie operacji
  -> wykonanie operacji -> dispatching -> wlasciwa edycja
  cofanie: wybor operacji -> dispatching -> wlasciwa edycja

  gdzie "wykonanie operacji" to albo "insert!" albo "extract!",
  natomiast historyczne operacje to Insert albo Remove.

  Mozna rozwazyc, czy nie lepiej po prostu miec operacje
  InsertExpression i RemoveExpression, albo moze zostawmy
  juz to i zamiast tego dodajmy InsertCharacters oraz
  RemoveCharacters, a takze SplitElements i MergeElements

Ale moze na razie to olejmy? Niech sobie bedzie ten
podwojny dispatching.

Byc moze tez bysmy chcieli sprawic, zeby Space bylo Textual
(ale akceptowalo tylko #\space i #\newline)?

Na razie olewamy.

No OK, wyglada na to, ze problemem jest to, ze odwrotnosc
"Insert" w przypadku znakow nie dziala najlepiej.

Dlatego moze dodamy operacje InsertCharacter i RemoveCharacter

OK, one zostaly dodane.

Teraz jednak wydaje sie, ze bylby sens, zeby Space
byl Textual.

* 02.02.2023

kilka planow na dzis:
- zrefaktoryzowac extract! w taki sposob, zeby biezacy
  "extract!" stal sie "extract-from-cell!" albo cos takiego,
  natomiast "glowny" extract! zeby dispatchowal:
  1. jezeli rodzicem wyrazenia jest pair?, to wywolujemy
     extract-expression-from-cell!
  2. jezeli docelowym wyrazeniem jest atom, to wywolujemy
     extract-character-from-atom!
  3. jezeli docelowym wyrazeniem jest text, to wywolujemy
     extract-character-from-text!
 (4. jezeli idzie o rozszerzenia, to na razie nie wiemy
     co robic, ale kiedys na pewno wymyslimy)

Trzeba tez bedzie cos pomyslec o refaktoryzacji, bo wydaje sie,
ze niektore rzeczy sa niepotrzebnie rozbite na (document-operations).
(editor-operations) oraz (history) - a wiekszosc operacji w tych
modulach dotyczy edycji dokumentu!

No, ale w praktyce wyszlo tak, ze dodalismy interfejs Textual,
i implementacje w Atom oraz Text.

Jeszcze bysmy chcieli wywalic te funkcje:

(atom-length a::Atom)
(insert-char! c::char a::Atom index::int)
(delete-char! a::Atom index::int)
(truncate-atom! a::Atom length::int)
(atom-subpart a::Atom start::int)

i zastapic je uzyciem metod interfejsu.

* 01.02.2023

Dzis bysmy sie zajeli tym, zeby "undo!" i "redo!" przy dodawaniu
spacji i pojedynczego znaku dzialalo poprawnie

Zaczniemy od pojedynczego znaku.

Nie ma problemu z dodawaniem znaku, poniewaz ten przypadek
obsluzylismy w funkcji "insert!".

Jednak funkcja "extract!" zostala przemianowana z funkcji
"take-cell!", ktora zawierala w sobie zalozenie, ze dotyczy
wyodrebniania elementow z komorek.

Teraz bedziemy chcieli odejsc od tego zalozenia.

Tzn. moze w okreslonych warunkach biezaca funkcja bedzie
sie nazywac "extract-from-cell!"

Powinnismy natomiast okreslic warunki wyodrebniania.

(extract! at: cursor from: document)

zasadniczo dziala w taki sposob, ze wyrazenie
znajdujace sie pod kursorem zostaje wyodrebnione.

I teraz tak: jezeli kursor jest "pelny", to

(eq? (the-expression at: cursor)
     (the-expression at: (cdr cursor)))

Czyli zasadniczo sprawdzamy, kto jest rodzicem naszego elementu:
- jezeli jest to para (a nasz element to nie spacja)
  to wywolamy "extract-tile-from-cell!"
- jezeli jest to atom, to usuwamy znak i zwracamy go
- jezeli jest to spacja, to zwrocimy albo nowa linie, albo
  znak spacji - chyba ze spacja jest pusta, wtedy
  albo scalamy elementy (jesli mozemy), albo nic
  nie robimy

No dobra, czyli przychodzi nam do glowy kolejna para operacji:

(SplitElement at: Cursor with: Space)
(MergeElements at: Cursor removing: Space)

ktore jednak mozna uznac za

(Remove element: Space from: Cursor)
(Insert element: Space at: Cursor)

* 31.01.2023

Musimy dokonac analizy intelektualnej problemu kursora
i historii.

Wydaje sie bowiem, ze mamy dwa rodzaje operacji:
drag&drop, ktory nie powinien wplywac na polozenie
kursora (a moze moze?) oraz edycje z klawiatury,
ktora ewidentnie wplywa na polozenie kursora

Byc moze latwiej bedzie zalozyc, ze drag&drop
rowniez wplywa na polozenia kursora (bo zasadniczo
to sie wydaje nie miec znaczenia), i ze zawsze
umieszczamy kursor za dodanym elementem
albo przed usunietym elementem.

-----


[Insert element: (f) at: (1 2 1 1)]
[Insert element: ('i') at: (1 3 1 1)]

===>
[Insert element: (fi) at: (1 2 1 1)]
[Insert element: ('n') at: (2 3 1 1)]

===>
[Insert element: (fin) at: (1 2 1 1)]
[Insert element: ('e') at: (3 3 1 1)]

===>
[Insert element: (fine) at: (1 2 1 1)]

Warunek jest taki:
- jezeli ostatnia operacja to wstawienie atomu A
dlugosci L na pozycji (_ n . x), a kolejna operacja
to wstawienie znaku C na pozycji
(L (+ n 1) . x), to zmieniamy operacje w historii
tak, ze jest to dopisanie symbolu AC na pozycji (_ n . x).


* 30.01.2023

OK, to teraz:
- albo piszemy testy jednostkowe
- albo probujemy implementowac poszczegolne
  funkcjonalnosci (pamietajac o zaimplementowaniu
  undo! i redo! oraz o polozeniach kursora)

Wydaje sie tez, ze trzeba przemyslec sprawe
zachowania kursora w kontekscie operacji
historycznych oraz drag&dropa.

Co do drag&dropa to mamy pewna koncepcje.


* 28.01.2023

<<analiza-edycji>>

Plan na teraz jest taki:
1. wypisujemy sobie wszystkie operacje dopuszczalne
  z klawiatury (na razie bez rozszerzen, ktore wszelako
  dodamy pozniej)
2. dla kazdej takiej operacji piszemy "test jednostkowy",
uwzgledniajacy rowniez operacje "undo!" i "redo!"
3. poczatkowo napiszemy po prostu duzo testow jednostkowych,
ale wiekszosc z nich pozostanie zakomentowana
4. bedziemy powoli dodawac funkcjonalnosci, odkomentowujac
poszczegolne testy - ale przy tym bedziemy uwazac, zeby
kod pozostal w miare ladny i elegancki, wiec nie bedziemy
sie spieszyc

A kiedy to sie uda zrealizowac, to wowczas zajmiemy sie
trawersowaniem i nawigowaniem po komentarzach oraz obsluga
pelnej skladni Kawy uzytej w implementacji GRASP, zeby dalej
moc edytowac GRASPa z poziomu niego samego.

Poniewaz zas zbliza sie luty, bedzie trzeba sie zajac
napisaniem zgloszenia na ELS.

No dobra, to teraz lista (albo tabela?)

Zacznijmy od tego:

A. insert-char!

  1. jezeli element pod kursorem to tekst, to po prostu
     wstawiamy znak do tego tekstu i zwiekszamy wierzcholek
     kursora o 1

 (2. analogicznie, jezeli element pod kursorem to rozszerzenie,
     to przekazujemy znak do rozszerzenia (i to juz ewentualnie
     rozszerzenie zajmuje sie kursorem))

  3. jezeli wstawiany znak to #\[, to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowe pudelko
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym pudelkiem
   (c. docelowo: jezeli mamy wybrana selekcje, to owijamy selekcje
     w pudelko)

  4. jezeli wstawiamy znak #\", to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowy Text
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym Textem

  5. jezeli wstawiamy spacje albo nowa linie, to:
    a. jezeli jestesmy na spacji, to odpowiednio powiekszamy spacje
    b. jezeli jestesmy na atomie, to dzielimy atom i dodajemy spacje

  6. jezeli wstawiamy atomowa litere w spacje, to tworzymy nowy atom

  7. jezeli wstawiamy atomowa litere w atom, to po prostu dopisujemy
     te litere do atomu (scalajac odpowiednio operacje Insert)


B. delete-backward!

  1. jezeli jestesmy na lewej krawedzi spacji za nawiasem
     zamykajacym, to kasujemy cale wyrazenie zamykane przez
     ten nawias
  2. jezeli jestesmy na lewej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawwiasy
  3. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta, kasujemy
        wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
     (od prawej strony)
  4. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na lewej krawedzi spacji za atomem, to
     usuwamy ostatni znak z tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja poprzedzajaca
     ten atom
  6. jezeli jestesmy wewnatrz spacji, to kasujemy poprzedzajaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak przed
     kursorem. Jezeli przed kursorem nie ma zadnego znaku,
     to usuwamy spacje przed atomem, chyba ze ta spacja jest
     zerowa - wowczas scalamy biezacy atom ze wczesniejszym
     atomem
  8. jezeli jestesmy na lewej krawedzi atomu i przed atomem
     jest nawias zamykajacy (oraz pusta spacja), to kasujemy cale
     wyrazenie
  9. jezeli jestesmy na lewej krawedzi atomu albo niepustej spacji
     za nawiasem otwierajacym, to nic robimy

C. delete-forward!

  1. jezeli jestesmy na prawiej krawedzi spacji przed nawiasem
     otwierajacym, to kasujemy cale wyrazenie otwierane przez
     ten nawias
  2. jezeli jestesmy na prawej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawiasy
  3. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta,
        kasujemy to wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
       (od lewej strony)
  4. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na prawej krawedzi spacji przed atomem,
     to usuwamy pierwszy znak tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja znajdujaca
     sie za tym atomem
  6. jezeli jestesmy wewnatrz spacji, to kasujemy nastepujaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak za kursorem.
     Jezeli za kursorem nie ma zadnego znaku, to usuwamy spacje
     za atomem, chyba ze ta spacja jest zerowa - wowczas scalamy
     biezacy atom z nastepujacym atomem

  8. jezeli jestesmy na prawej krawedzi atomu i za atomem
     jest nawias otwierajacy (oraz pusta spacja), to kasujemy
     cale wyrazenie
  9. jezeli jestesmy na prawej krawedzi atomu albo niepustej
     spacji przed nawiasem zamykajacym, to nic nie robimy


* 26.01.2023

Odkrylismy, ze klawisze w kliencie terminalowym nie sa
obslugiwane poprawnie, i mozemy sie sprobowac zajac
ich naprawa.

OK, to juz zrobione.

I co daley?

Trzeba w jakis sposob usystematyzowac edycje. Ogolnie
mamy dwie kwestie:
- modyfikacja dokumentu
- modyfikacja polozenia kursora

Do tego dochodzi nam jeszcze kwestia "odwracalnosci operacji",
w tym - w szczegolnosci - odwracalnosc operacji kasowania
(oraz scalanie operacji edycji na poziomie znaku w historii)

Dobrze by bylo rowniez rozprawic sie z kwestia reprezentacji
selekcji, bo aktualnie wydaje sie, ze (the-selection-anchor)
nie dziala zbyt dobrze.

Wreszcie byloby doskonale, gdybysmy mieli pelna obsluge selekcji.
Ale wydaje sie, ze to nie na teraz.

Ogolnie musimy tez pamietac, ze oprocz edycji z klawiatury
oraz wsparcia dla komentarzy, chcielibysmy tez w jakis sposob
reprezenotwac quote'y i unquote'y.

Natomiast w kwestii najpredszych zmian, warto byloby dodac
kolorowanie wybranego nawiasu, i warto by bylo tez obsluzyc
podswietlanie nawiasu na ktorym znajduje sie kursor.

* 25.01.2023

Wczoraj sie udalo zrobic dopisywanie znakow do atomow.
Dzisiaj natomiast zajelibysmy sie spacjami i nowymi liniami.

Chodzi zasadniczo o to, ze:
- znak spacji lub nowej linii na poczatku albo na koncu atomu
  powinien zostac dodany do przylegajacej spacji
- znak spacji lub nowej linii wewnatrz atomu powinien spowodowac
  przelamanie tego atomu
- znak spacji albo nowej linii wewnatrz spacji powinien
  pozostac w tej spacji
- znak spacji albo nowej linii wewnatrz Textu powinien
  po prostu zostac do niej odpowiednio dodany

Takie rzeczy chcielibysmy zaimplementowac, ale tez przy okazji
pojawia sie perspektywa refaktoryzacji - chodzi o to, czy
nie daloby sie zrobic tak, zeby to box, albo spacja, albo tekst
decydowaly o tym, w jaki sposob sie zachowac - bo ostatecznie
rozszerzenia powinny rowniez byc w stanie obslugiwac inputy
na swoj sposob.

---

po dzisiejszym dniu nasuwa sie kilka uwag:
1. dziwne zachowanie kursora
2. (the-selection-anchor) to upierdliwy mechanizm,
bo trzeba sie nim zajmowac przy kazdej aktualizacji kursora
3. chcielibysmy miec symetrie pomiedzy dodawaniem i usuwaniem
4. mamy kilka dziwnych bledow


* 24.01.2023

Ponizej jest sobie costam jakos tam napisane.

Natomiast tym, na czym zalezy nam przede wszystkim,
sa testy jednostkowe w test-editor-operations.scm.

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone - zmienic nazwe na "extract-from-box!"?

2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu pierwszego
     czyli:
     - merge-boxes!
     - merge-atoms!

4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
     - merge-texts!
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

1. insert! [lista do spacji]
   - wyodrebnic "insert-into-box!"
2. insert! [spacja do atomu]
   - rozbijamy atom na dwa -
3. insert! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. insert! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. insert! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem



* 23.01.2023

Musimy dodac obsluge wstawiania spacji w spacje
do procedury insert!, jak rowniez obsluge pozostalych
sytuacji, takich jak:

- wstawienie znaku w Atom
- wstawienie znaku w Text
- wstawienie spacji/nowej linii w Atom
- wstawienie spacji/nowej linii w Text

Z pewnoscia chcemy tez napisac testy jednostkowe


* 22.01.2023

Mini-plan jest taki, zeby przeniesc funkcje
delete-forward!, delete-backward!, insert-character!
oraz delete! do primitive-terminal-client!
i dodac im przedrostek np. old!, tak zebysmy
mieli do nich dostep, ale zebysmy mogli zaczac
pisac nasze funkcje od poczatku.

Rzecz w tym, ze chcielibysmy, zeby te nowe funkcje
byly juz zaposredniczone w historii.

No ale. Plan na jutro rano jest taki, zeby:
- scommitowac zminy nazw z take-cell! na extract!
oraz ze splice! na insert!
- scommitowac przeniesienie funkcji z editor-operations
do primitive-terminal-client oraz nadanie przedrostka /old/
- zaczac pisac implementacje dla insert-character!
(i zmodyfikowac domyslna funkcje keymap tak, zeby
wywolywala insert-character!)


* 21.01.2023

No, to teraz mozemy radosnie
dodawac nowy ficzer edycji do GRASPa.

Najogolniej rzecz biorac, chcemy, zeby
wcisniecie klawisza powodowalo domyslnie
wywolanie

(insert-character! (unicode-input)
             into: (the-document)
               at: (the-cursor))

gdzie:
- jezeli input to lewy nawias i jestesmy na spacji,
tworzymy nowe pudelko
- jezeli input to prawy nawias i jestesmy na lewym nawiasie,
atomie albo spacji, to idziemy do nastepnego zamykajacego nawiasu

dosc obszerna analize do przetrawienia mamy napisana
6 stycznia.

najblizsze commit w poniedzialek; programowanie
na telefonie jest duzo dostepniejsze, ale
na laptopie komfort pisania jest nieporownywalnie
lepszy.

OK, to z takich bardziej podstawowych rzeczy:
- chcemy zmienic nazwy z take-cell! na extract!
i ze splice! na insert!
(nie do konca juz pamietamy, dlaczego chcemy,
ale mimo wszystko nadal chcemy?)

W kazdym razie nazwy zostaly juz zmienione.

No i co dalej?

Moze bysmy usuneli:
- primitive-terminal-client
- funkcje "delete-forward!", "delete-backward!"
  oraz "insert-character!" z (editor-operations),
  zeby je moc zaimplementowac od nowa?

Nooo, tyle ze tam juz jakas funkcjonalnosc jest.

Mozemy zatem albo przeprowadzic analize tego,
co juz mamy, albo - w oparciu o wczesniejsza analize
- zaprojektowac to, co powinnismy miec.

Co dziwne, wydaje sie, ze niektore rzeczy
dzialaja.

* 19.01.2023

pozostale dwa punkty ze wtorkowej listy odhaczone

* 18.01.2023

pierwsy punkt z wczorajszej listy odhaczony.
teraz nam pozostaje dodac extend-selection
(usuwajac tego przykrego enuma)

* 17.01.2023

zadania na dzis/jutro:
- przetestowac desktop-client na asusie
  (i ew. ponaprawiac)
- uzupelnic mapy klawiatury
- dodac (shift left) oraz (shift right) jako ekspansje selekcji

* 14.01.2023

zbudowalismy juz zalazki map klawiatur dla
trzech klientow

teraz bysmy chcieli usunac stare zdarzenia
z modulu pane, i zastapic je nowymi

- bedzie to wymagalo translacji kodu
  zdarzenia do odpowiedniej postaci
  (w tym ustawienia parametru (unicode-input)
  tam gdzie to stosowne)

  w przypadku kazdego klienta bedzie to trzeba
  robic inaczej, i dlatego nalezy ustalic jakas
  kolejnosc:
  - najpierw klient terminalowy
  - po nim klient androidowy
  - a na koncu klient desktopowy
    (ktotego i tak nie mamy na razie jak
    przetestowac)

natomiast plany dlugofalowe:
+ skonczyc ta refaktoryzacje
+ zaimplementowac edycje
+ obsluga komentarzy (renderowanie i nawigacja)
+ obsluga uzytych rozszerzen Kawy/rezygnacja z nieuzytych rozszerzen
+ ladowanie i zapisywanie plikow; podzial ekranu
+ zgloszenie na ELS
+ mechanizm rozszerzen
+ poszczegolne rozszerzenia + sukcesywny rozwoj API do rysowania
+ evisulator
+ edytor grafow
+ obsluga selekcji (kopiowanie, wklejanie, usuwanie, historia)
+ naprawianie bledow (w tym zwiazanych z drag&dropem)
+ prezentacja na ELS
+ pierwsze wydanie, 2 aplikacje w sklepie
+ zgloszenie na StrangeLoop
+ siec spolecznosciowa

+ SICP - GRASP edition
+ The Little Schemer - GRASP edition
  (i podobnie: The Seasoned Schemer, The Reasoned Schemer)
+ The Dream Machine - GRASP edition
+ The Way Things Work - GRASP edition

+ The Art of Metaprogramming in Scheme

ok, tosmy sobie odplyneli

teraz do roboty: zmieniamy sposob obslugi
klawiszy w kliencie terminalowym - ale trzeba
jeszcze pomyslec co z obsluga myszy/wskaznikow

ok, klient terminalowy juz obskoczony.
teraz jeszcze tylko zostaje androidowy i desktopowy.

na razie sie zajmiemy androidowym

ok, wyglada na to ze to tez sie udalo.


* 13.01.2023

Mamy sobie 3 klienty. I teraz dla tych
3 klientow bedziemy chcieli zbudowac
moduly (android-key-map) (desktop-key-map)
oraz (teminal-key-map).

* 12.01.2023

No dobra, to teraz - zeby byla jasnosc - zaczynamy
od uwspolnionego systemu obslugi zdarzen, w ktorym
bedzie tylko zdarzenie 'key-typed', a funkcje beda
definiowane w pliku init.scm.

Na razie nie robmy hierarchicznej obslugi, bo to
moze byc overengineering.

Dopiero jak to bedzie gotowe, zajmiemy sie 'wstawianiem
znakow', ze szczegolnym uwzglednieniem aspektu historii
/cofania.

* 11.01.2023

trzeba obmyslic strategie implementacji
nowego podsystemu wprowadzania

W androidzie mamy:
getKeyCode(), getScanCode(), getMetaState()


w androidzie chcemy zmienic podsystem zdarzen
tak zeby na razie po prostu wypluwal zdarzenie
do logow


(active-pointers) ::(list-of int)

(pointer-position index::int) ::Position

(unicode-input)::char

w KeyboardEvent z awt mamy metode getKeyChar,
ktora zwraca kod albo CHAR_UNDEFINED.

(define-mapping (key-handler key-code)::(maps () to: void)
  (lambda ()::void
    (and-let* ((c (unicode-input)))
      (insert-character! c))))

Jeszcze trzeba rozwazyc opcje dodawania trybow,
tak zeby mozna bylo przeslaniac sobie tablice znakow
w roznych kontekstach.


(define-type (KeyMap bindings: (maps (key::int) to: () to: void)
                     parent: KeyMap))

* 10.01.2023

Wczorajszybi dzisiejszy dzien to glownie
walka z ewaluacja w kliencie androidowym
(i to trzeba odnotowac)


Jutro j pojutrze beda comity:
- ocpowiedziec na issue
- commitnw grasp-android

- zarchiwizowac grasp-android
- scomitowac zmiany tutaj

Na razie plan jest taki, ze chcemy
ujednolicic konfiguracje po stronie
androida, terminala i awt, szukajac
najwiekzzsgo wxpolnego mianownika

nastepnie bysmy te konfiguracje
przeniesli do init.scm

nastepnie bysmy juz zaczeli walke
z podpinaniem funkcji do edycji
dokumentu

fajnie by bylo to zrobic do konca
stycznia - i jeszcze obsluge
komentarzy w rendererze, oraz
otwieranie i zapisywanie plikow
oraz podzial ekranu

na pewno tez troche pracy bedzie
trzeba poswiecic zeby dopiescic
klienta awt

na dalszy ogien idzie mechanizm
rozszerzen oraz ewaluacja wyrazen
roraz juz partykularne rozszerzenia
(Img src: ...), wizualny ewaluator,
edytor grafow, chmura punktow

natomiast priorytetem powinno
byc doproeadzenie do sytuacji
w ktorej GRASP rozwijamy w GRASP,
a nie w Emacsie

----------------------------------

ok, to co teraz robimy?

trzeba bedzie rozehrac zdarzemia
z awt na kawalki

moze warto zrobic tabelke

|---------+------------+-------------+-----------|
| system  | press      | release     | type      |
|---------+------------+-------------+-----------|
| AWT     | keyPressed | keyReleasee | keyTyped  |
|---------+------------+-------------+-----------|
| Lantrna |            |             | readInput |
|---------+------------+-------------+-----------|
| Android | onKeyDown  | onKeyUp     |           |
|---------+------------+-------------+-----------|

Ok, i teraz co?

Teraz musimy odwzorowac klawisze i sekwencje
w ich nazwy. Na przyklad

(on-key '(ctrl alt shit x) cut-selection!)

czy cos

i teraz bysmy sobie zrobili takie cos,
ze tlumaczylibysmy sekwencje na wartosc
typu long, i systemy zdarzen w poszczegolnych
klientach robilyby to samo - i mielibysmy
tablice haszujaca, ktora mapuje nam
klawisze na odpowiednie procedury

Poniewaz jednak nie chcemy tracic
dotychczasowej funkcjonalnosci,
moze wypiszmy sobie jakie do tej porg
mielismy wiazania w poszczegolnych
klienach:

** klient terminalowy:

  (set! (on-key-press KeyType:ArrowLeft)
	(lambda ()
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowRight)
	(lambda ()
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowUp)
	move-cursor-up!)

  (set! (on-key-press KeyType:ArrowDown)
	move-cursor-down!)

  (set! (on-key-type #\x) exit)

** klient desktopowy

  (set! (on-key-press KeyEvent:VK_LEFT)
	(lambda _
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_RIGHT)
	(lambda _
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_UP)
	move-cursor-up!)

  (set! (on-key-press KeyEvent:VK_DOWN)
	move-cursor-down!)

  (set! (on-key-press KeyEvent:VK_Z)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:undo!)))))

  (set! (on-key-press KeyEvent:VK_Y)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:redo!)))))

** klient androidowy:

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_LEFT)
      (lambda _
	(move-cursor-left!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_RIGHT)
      (lambda _
	(move-cursor-right!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_UP)
      move-cursor-up!)

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_DOWN)
      move-cursor-down!)


* 09.01.2023

wyglada na to, ze mamy takie problemy
implementacyjne:
- w wersji skompilowanej, init.scm musi
  ladowac moduly, z ktorych korzysta
- ale trzy klienty beda musialy definiowac
  on-key na swoj sposob
- ale czy rzeczywiscie?

Definicja on-key bedzie taka sama, tylko
sposob wywolania bedzie rozny.

Teraz trzeba:

- usunac key-pressed! i key-released! z (panel),
  moze tez zmienic nazwe na (pane)

- zrobic jakos tak, zeby wywolywac odpowiednia
  funkcje dla kazdego klienta

* 08.01.2023

plan jak na razie wyglada zacnie.

jego realizacje zaczelibysmy od tego, ze kazdy
klient wykonywalby plik init.scm - na poczatku
to moze byc po prostu wypisanie loga albo cos.

co wiecej, zmiany w kliencie desktopowym
i terminalowym mozemy robic na laptopie

* 07.01.2023

Usunelismy funkcje "insert!", ale jest pewien
problem z testowaniem - na telefonie mozemy
jedynie przetestowac dzialanie aplikacji
na telefon.

Poza tym jest jeszcze kwestia taka, ze chcielibysmy
zbudowac przenosny interfejs wwjscia/wyjscia
pomiedzy klientami - cos w rodzaju

(on-key '(ctrl z) undo!)

(on-key '(ctrl y) redo!)

i wowczas bysmy sobie zdefiniowali:

(on-key 'space insert-space!)

(on-key 'backspace delete-backward!)

(on-key 'delete delete-forward!)

(on-key 'enter insert-newline!)

(on-key 'left move-cursor-left!)

(on-key '(shift left) expand-selection-left!)

(on-key 'right move-cursor-right!)

(on-key '(shift right) expand-selection-right!)

Mielibysmy tez takie funkcje:

(active-pointers) ::int

(pointer-position index::int) ::Position

(unicode-input)::char

Bedziemy chcieli miec plik init.scm, zawierajacy
powyzsze definicje.

Od strony implementacyjniej bysmy chcieli miec:
- bezposrednia tablice
- tablice shift dla klawiszy sterujaych
- tablice ctrl
- tablice alt
- tablice ctrl+alt
- tablice ctrl+shift
- tablice alt+shift
- tablice ctrl+alt+shift

Albo nawet nie. Moze byc jedna tablica.

* 06.01.2023

Idealnie byloby, gdybysmy nie dodawali
zadnych nowych operacji, tylko poprzestali
na Move, Remove oraz Insert.

Dzielenie atomu odbywaloby sie na zasadzie
wstawienia spacji w atom, laczenie - na zasadzie
usuniecia spacji itd.

Trzeba to bedzie sobie rozpisac.
Move -> take-cell!, splice!
Remove -> take-cell!
Insert -> splice!

Trzeba bedzie pozmieniac nazwy:
1. insert! z modulu (history) na cos (to trywialna
   funkcja uzyta w jednym miejscu w (panel))
2. ze splice! na insert!
3. z take-cell! na extract!

I teraz: funkcje (nowe) insert! i extract!
bedziemy musieli zmienic tak, zeby dzialaly
w roznych konfiguracjach

(docelowo do extract! bedziemy chcieli
jeszcze dodac argument numeryczny, tak
zeby moc uzywac tej funkcji do obslugi
selekcji, zas splice! rowniez bedzie
trzeba do tego celu przysposobic)

No dobra, ale teraz chyba bedzie trzeba
rozwazyc

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone: wydobywamy element
     z wnetrza pudelka
2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden3. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu
     pierwszego
4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

i teraz insert! analogicznie:

1. splice! [lista do spacji]
   - juz obsluzone (wklejamy liste pomiedzy element
     poprzedzajacy spacjena kolejny element)
2. splice! [spacja do atomu]
   - rozbijamy atom na dwa
3. splice! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. splice! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. splice! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem

1. extract-tile! at: Cursor from: document
   splice-list! list at: Cursor into: document
2. merge-atoms! at: Cursor in: document
   split-atom! at: Cursor in: document
3. merge-boxes! at: Cursor in: document
   split-box! at: Cursor in: document
4. merge-texts! at: Cursor in document
   split-text! at: Cursor in: document
5. remove-characters! at: Cursor from: document
   insert-charactets! at: Cursor into: document

* 02.01.2023

Dwie pierwsze zmiany w nowym roku:
- archiwizacja grasp-android
- odpowiedziec na "issue" w nowym repo

Natomiast to, czym teraz bysmy sie chcieli
zajac, to edycja dokumentow z klawiatury,
czyli:

- jak piszemy [, to tworzymy nowe puste pudelko
- jak piszemy ]. to wychodzimy z pudelka

W kazdym razie to sie dzieje w kontekscie
pudelek - bo w przypadku Textu dla niesterujacych
znakow zawsze owe znaki dopisujemy (pewnym wyjatkiem
moze byc \, ale to jeszcze trzeba przemyslec)

- jak piszemy ", to tworzymy nowy Text

jak wciskamy znak drukowalny, to:
- jezeli jestesmy na spacji, to tworzymy
  nowy atom
- jezeli jestesmy na atomie, to dopisujemy
  znak

Wyjatki:
- wcisniecie spacji, gdy jestesmy na spacji,
  dodaje spacje pozioma
- wcisniecie entera dodaje spacje pionowa
- wcisniecie spacji albo entera na atomie
  powoduje rozbicie atomu (chyha ze jestesmy
  na ostatniej pozycji - wtedy edytujemy
  nastepujaca spacje)

Trzeba bedzie zaczac od napisanis testow
dla takiego czegos, oraz dodac odpowiednie
operacjendo historii edycji

Rowniez chcielibysmy obsluzyc dzialanie
klawisza backspace.

Jezeli idzie o historie, to mozemy zamodelowac:
- rozszczepienie atomu jako wstawienie spacji
- scalenie atomu jako usuniecie spacji

Dzieki temu nie musimy dodawac nowych operacji
do historii.

Mamy zatem do dodania nastepujace operacje:
