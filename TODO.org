* 07.02.2023

Teraz rzeczy do zrobienia:
- optymalizacja historii: chcemy scalac ze soba operacje
InsertCharacter o ile naleza do tej samej klasy
(czyli dodawanie spacji albo dodawanie nie-spacji)
no i oczywiscie spelnione sa warunki ciaglosci kursora.

To jedna rzecz.

Druga rzecz, to chcemy przetestowac czy operacje
dzielenia i scalania atomu dobrze dzialaja.

Trzecia rzecz wreszcie, to chcemy zaimplementowac
operacje kasowania.

* 06.02.2023

Mamy mala zagwozdke dotyczaca tego, w jaki sposob reprezentowac
usuwanie znaku w sytuacji, gdy robimy delete-forward! - ale
to na szczescie jeszcze nie jest palaca kwestia.

No dobra, dzis zajelibysmy sie tym:
- jezeli jestesmy na granicy atomu (lewej albo prawej)
  i wstawiamy bialy znak, to InsertCharacter powinien
  dotyczyc nie tego atomu, tylko graniczacej spacji
- Space powinno implementowac Textual
- jezeli wstawiamy bialy znak do srodka atomu, to powinnismy
  wygenerowac operacje Split, natomiast jezeli kasujemy
  spacje z wnetrza atomu, to powinnismy wygenerowac operacje
  Join

I taki oto jest plan na dzis.

No i OK. I teraz mamy takie cus:

(define-interface Textual ()
  (insert-char! c::char index::int)::void
  (delete-char! index::int)::char
  (char-ref index::int)::char
  (truncate! length::int)::void
  (subpart start::int)::Textual
  (text-length)::int
  )

Natomiast po stronie spacji to mamy metody:
- insert-space!
- insert-break!
- delete-space!

oraz funkcje
- insert-space!
- insert-break!
- insert-whitespace!
- delete-space!
- join-spaces!
- split-space!

Dobrze by bylo, gdybysmy przynajmniej pojeciowo
sprobowali sobie zmapowac, czy tez wypowiedziec
relacje, pomiedzy join-spaces! oraz split-space!,
a metodami subpart oraz truncate! interfejsu
Textual.

Otoz: subpart i truncate! sa uzywane w funkcji
insert! w przypadku dzielenia atomu.

Czyli teoretycznie funkcje "split-space!" moglibysmy
zaimplementowac analogicznie.

Ale jednak pomysl mamy duzo lepszy - usunmy
funkcje subpart i truncate, i zamiast nich
stworzmy metode split!

OK, to mamy:
- metode split! zamiast truncate! i subpart w Textual
- Space jako instancje Textual


* 04.02.2023

Wczoraj udalo sie wprowadzic InsertCharacter i RemoveCharacter
- tzn dodawanie znakow do obiektow Textual - ale koszt tego
przedsiewziecia byl taki, ze teraz mamy zepsuta obsluge spacji.

Wydaje sie tez, ze chcielibysmy:
- uzywac nowej metody (cursor) do wyliczania polozenia
kursora
- usunac reczne manipulacje kursorem z kodu
- moze bysmy zrobili tak, ze po prostu funkcja apply!
bedzie zwracala kursor, i usunelibysmy metode
(cursor)?


* 03.02.2023

wczorajszy plan o refaktoryzacji "Extract" pozostaje w mocy.
Ale do tego dochodzi jeszcze kilka pomyslow:

- na razie wydaje sie, ze probujemy zrobic takie cos:
  edycja: wcisniecie klawisza -> dispatching -> dodanie operacji
  -> wykonanie operacji -> dispatching -> wlasciwa edycja
  cofanie: wybor operacji -> dispatching -> wlasciwa edycja

  gdzie "wykonanie operacji" to albo "insert!" albo "extract!",
  natomiast historyczne operacje to Insert albo Remove.

  Mozna rozwazyc, czy nie lepiej po prostu miec operacje
  InsertExpression i RemoveExpression, albo moze zostawmy
  juz to i zamiast tego dodajmy InsertCharacters oraz
  RemoveCharacters, a takze SplitElements i MergeElements

Ale moze na razie to olejmy? Niech sobie bedzie ten
podwojny dispatching.

Byc moze tez bysmy chcieli sprawic, zeby Space bylo Textual
(ale akceptowalo tylko #\space i #\newline)?

Na razie olewamy.

No OK, wyglada na to, ze problemem jest to, ze odwrotnosc
"Insert" w przypadku znakow nie dziala najlepiej.

Dlatego moze dodamy operacje InsertCharacter i RemoveCharacter

OK, one zostaly dodane.

Teraz jednak wydaje sie, ze bylby sens, zeby Space
byl Textual.

* 02.02.2023
  
kilka planow na dzis:
- zrefaktoryzowac extract! w taki sposob, zeby biezacy
  "extract!" stal sie "extract-from-cell!" albo cos takiego,
  natomiast "glowny" extract! zeby dispatchowal:
  1. jezeli rodzicem wyrazenia jest pair?, to wywolujemy
     extract-expression-from-cell!
  2. jezeli docelowym wyrazeniem jest atom, to wywolujemy
     extract-character-from-atom!
  3. jezeli docelowym wyrazeniem jest text, to wywolujemy
     extract-character-from-text!
 (4. jezeli idzie o rozszerzenia, to na razie nie wiemy
     co robic, ale kiedys na pewno wymyslimy)

Trzeba tez bedzie cos pomyslec o refaktoryzacji, bo wydaje sie,
ze niektore rzeczy sa niepotrzebnie rozbite na (document-operations).
(editor-operations) oraz (history) - a wiekszosc operacji w tych
modulach dotyczy edycji dokumentu!

No, ale w praktyce wyszlo tak, ze dodalismy interfejs Textual,
i implementacje w Atom oraz Text.

Jeszcze bysmy chcieli wywalic te funkcje:

(atom-length a::Atom)
(insert-char! c::char a::Atom index::int)
(delete-char! a::Atom index::int)
(truncate-atom! a::Atom length::int)
(atom-subpart a::Atom start::int)

i zastapic je uzyciem metod interfejsu.

* 01.02.2023

Dzis bysmy sie zajeli tym, zeby "undo!" i "redo!" przy dodawaniu
spacji i pojedynczego znaku dzialalo poprawnie

Zaczniemy od pojedynczego znaku.

Nie ma problemu z dodawaniem znaku, poniewaz ten przypadek
obsluzylismy w funkcji "insert!".

Jednak funkcja "extract!" zostala przemianowana z funkcji
"take-cell!", ktora zawierala w sobie zalozenie, ze dotyczy
wyodrebniania elementow z komorek.

Teraz bedziemy chcieli odejsc od tego zalozenia.

Tzn. moze w okreslonych warunkach biezaca funkcja bedzie
sie nazywac "extract-from-cell!"

Powinnismy natomiast okreslic warunki wyodrebniania.

(extract! at: cursor from: document)

zasadniczo dziala w taki sposob, ze wyrazenie
znajdujace sie pod kursorem zostaje wyodrebnione.

I teraz tak: jezeli kursor jest "pelny", to

(eq? (the-expression at: cursor)
     (the-expression at: (cdr cursor)))

Czyli zasadniczo sprawdzamy, kto jest rodzicem naszego elementu:
- jezeli jest to para (a nasz element to nie spacja)
  to wywolamy "extract-tile-from-cell!"
- jezeli jest to atom, to usuwamy znak i zwracamy go
- jezeli jest to spacja, to zwrocimy albo nowa linie, albo
  znak spacji - chyba ze spacja jest pusta, wtedy 
  albo scalamy elementy (jesli mozemy), albo nic
  nie robimy

No dobra, czyli przychodzi nam do glowy kolejna para operacji:

(SplitElement at: Cursor with: Space)
(MergeElements at: Cursor removing: Space)

ktore jednak mozna uznac za

(Remove element: Space from: Cursor)
(Insert element: Space at: Cursor)

* 31.01.2023

Musimy dokonac analizy intelektualnej problemu kursora
i historii.

Wydaje sie bowiem, ze mamy dwa rodzaje operacji:
drag&drop, ktory nie powinien wplywac na polozenie
kursora (a moze moze?) oraz edycje z klawiatury,
ktora ewidentnie wplywa na polozenie kursora

Byc moze latwiej bedzie zalozyc, ze drag&drop
rowniez wplywa na polozenia kursora (bo zasadniczo
to sie wydaje nie miec znaczenia), i ze zawsze
umieszczamy kursor za dodanym elementem
albo przed usunietym elementem. 

-----


[Insert element: (f) at: (1 2 1 1)]
[Insert element: ('i') at: (1 3 1 1)]

===>
[Insert element: (fi) at: (1 2 1 1)]
[Insert element: ('n') at: (2 3 1 1)]

===>
[Insert element: (fin) at: (1 2 1 1)]
[Insert element: ('e') at: (3 3 1 1)]

===>
[Insert element: (fine) at: (1 2 1 1)]

Warunek jest taki:
- jezeli ostatnia operacja to wstawienie atomu A
dlugosci L na pozycji (_ n . x), a kolejna operacja
to wstawienie znaku C na pozycji
(L (+ n 1) . x), to zmieniamy operacje w historii
tak, ze jest to dopisanie symbolu AC na pozycji (_ n . x).


* 30.01.2023

OK, to teraz:
- albo piszemy testy jednostkowe
- albo probujemy implementowac poszczegolne
  funkcjonalnosci (pamietajac o zaimplementowaniu
  undo! i redo! oraz o polozeniach kursora)

Wydaje sie tez, ze trzeba przemyslec sprawe
zachowania kursora w kontekscie operacji
historycznych oraz drag&dropa.

Co do drag&dropa to mamy pewna koncepcje.


* 28.01.2023

Plan na teraz jest taki:
1. wypisujemy sobie wszystkie operacje dopuszczalne
  z klawiatury (na razie bez rozszerzen, ktore wszelako
  dodamy pozniej)
2. dla kazdej takiej operacji piszemy "test jednostkowy",
uwzgledniajacy rowniez operacje "undo!" i "redo!"
3. poczatkowo napiszemy po prostu duzo testow jednostkowych,
ale wiekszosc z nich pozostanie zakomentowana
4. bedziemy powoli dodawac funkcjonalnosci, odkomentowujac
poszczegolne testy - ale przy tym bedziemy uwazac, zeby
kod pozostal w miare ladny i elegancki, wiec nie bedziemy
sie spieszyc

A kiedy to sie uda zrealizowac, to wowczas zajmiemy sie
trawersowaniem i nawigowaniem po komentarzach oraz obsluga
pelnej skladni Kawy uzytej w implementacji GRASP, zeby dalej
moc edytowac GRASPa z poziomu niego samego.

Poniewaz zas zbliza sie luty, bedzie trzeba sie zajac
napisaniem zgloszenia na ELS.

No dobra, to teraz lista (albo tabela?)

Zacznijmy od tego:

A. insert-char!

  1. jezeli element pod kursorem to tekst, to po prostu
     wstawiamy znak do tego tekstu i zwiekszamy wierzcholek
     kursora o 1

 (2. analogicznie, jezeli element pod kursorem to rozszerzenie,
     to przekazujemy znak do rozszerzenia (i to juz ewentualnie
     rozszerzenie zajmuje sie kursorem))

  3. jezeli wstawiany znak to #\[, to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to 
     tworzymy nowe pudelko
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym pudelkiem
   (c. docelowo: jezeli mamy wybrana selekcje, to owijamy selekcje
     w pudelko)

  4. jezeli wstawiamy znak #\", to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to 
     tworzymy nowy Text
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym Textem

  5. jezeli wstawiamy spacje albo nowa linie, to:
    a. jezeli jestesmy na spacji, to odpowiednio powiekszamy spacje
    b. jezeli jestesmy na atomie, to dzielimy atom i dodajemy spacje

  6. jezeli wstawiamy atomowa litere w spacje, to tworzymy nowy atom

  7. jezeli wstawiamy atomowa litere w atom, to po prostu dopisujemy
     te litere do atomu (scalajac odpowiednio operacje Insert)


B. delete-backward!

  1. jezeli jestesmy na lewej krawedzi spacji za nawiasem
     zamykajacym, to kasujemy cale wyrazenie zamykane przez
     ten nawias
  2. jezeli jestesmy na lewej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawwiasy
  3. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta, kasujemy
        wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
     (od prawej strony)
  4. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na lewej krawedzi spacji za atomem, to
     usuwamy ostatni znak z tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja poprzedzajaca
     ten atom
  6. jezeli jestesmy wewnatrz spacji, to kasujemy poprzedzajaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak przed
     kursorem. Jezeli przed kursorem nie ma zadnego znaku,
     to usuwamy spacje przed atomem, chyba ze ta spacja jest
     zerowa - wowczas scalamy biezacy atom ze wczesniejszym
     atomem
  8. jezeli jestesmy na lewej krawedzi atomu i przed atomem
     jest nawias zamykajacy (oraz pusta spacja), to kasujemy cale
     wyrazenie
  9. jezeli jestesmy na lewej krawedzi atomu albo niepustej spacji
     za nawiasem otwierajacym, to nic robimy

C. delete-forward!

  1. jezeli jestesmy na prawiej krawedzi spacji przed nawiasem
     otwierajacym, to kasujemy cale wyrazenie otwierane przez
     ten nawias
  2. jezeli jestesmy na prawej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawiasy
  3. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta,
        kasujemy to wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
       (od lewej strony)
  4. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na prawej krawedzi spacji przed atomem,
     to usuwamy pierwszy znak tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja znajdujaca
     sie za tym atomem
  6. jezeli jestesmy wewnatrz spacji, to kasujemy nastepujaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak za kursorem.
     Jezeli za kursorem nie ma zadnego znaku, to usuwamy spacje
     za atomem, chyba ze ta spacja jest zerowa - wowczas scalamy
     biezacy atom z nastepujacym atomem

  8. jezeli jestesmy na prawej krawedzi atomu i za atomem
     jest nawias otwierajacy (oraz pusta spacja), to kasujemy
     cale wyrazenie
  9. jezeli jestesmy na prawej krawedzi atomu albo niepustej
     spacji przed nawiasem zamykajacym, to nic nie robimy


* 26.01.2023

Odkrylismy, ze klawisze w kliencie terminalowym nie sa
obslugiwane poprawnie, i mozemy sie sprobowac zajac
ich naprawa.

OK, to juz zrobione.

I co daley?

Trzeba w jakis sposob usystematyzowac edycje. Ogolnie
mamy dwie kwestie:
- modyfikacja dokumentu
- modyfikacja polozenia kursora

Do tego dochodzi nam jeszcze kwestia "odwracalnosci operacji",
w tym - w szczegolnosci - odwracalnosc operacji kasowania
(oraz scalanie operacji edycji na poziomie znaku w historii)

Dobrze by bylo rowniez rozprawic sie z kwestia reprezentacji
selekcji, bo aktualnie wydaje sie, ze (the-selection-anchor)
nie dziala zbyt dobrze.

Wreszcie byloby doskonale, gdybysmy mieli pelna obsluge selekcji.
Ale wydaje sie, ze to nie na teraz.

Ogolnie musimy tez pamietac, ze oprocz edycji z klawiatury
oraz wsparcia dla komentarzy, chcielibysmy tez w jakis sposob
reprezenotwac quote'y i unquote'y.

Natomiast w kwestii najpredszych zmian, warto byloby dodac
kolorowanie wybranego nawiasu, i warto by bylo tez obsluzyc
podswietlanie nawiasu na ktorym znajduje sie kursor.

* 25.01.2023

Wczoraj sie udalo zrobic dopisywanie znakow do atomow.
Dzisiaj natomiast zajelibysmy sie spacjami i nowymi liniami.

Chodzi zasadniczo o to, ze:
- znak spacji lub nowej linii na poczatku albo na koncu atomu
  powinien zostac dodany do przylegajacej spacji
- znak spacji lub nowej linii wewnatrz atomu powinien spowodowac
  przelamanie tego atomu
- znak spacji albo nowej linii wewnatrz spacji powinien
  pozostac w tej spacji
- znak spacji albo nowej linii wewnatrz Textu powinien
  po prostu zostac do niej odpowiednio dodany

Takie rzeczy chcielibysmy zaimplementowac, ale tez przy okazji
pojawia sie perspektywa refaktoryzacji - chodzi o to, czy
nie daloby sie zrobic tak, zeby to box, albo spacja, albo tekst
decydowaly o tym, w jaki sposob sie zachowac - bo ostatecznie
rozszerzenia powinny rowniez byc w stanie obslugiwac inputy
na swoj sposob.

---

po dzisiejszym dniu nasuwa sie kilka uwag:
1. dziwne zachowanie kursora
2. (the-selection-anchor) to upierdliwy mechanizm,
bo trzeba sie nim zajmowac przy kazdej aktualizacji kursora
3. chcielibysmy miec symetrie pomiedzy dodawaniem i usuwaniem
4. mamy kilka dziwnych bledow


* 24.01.2023

Ponizej jest sobie costam jakos tam napisane.

Natomiast tym, na czym zalezy nam przede wszystkim,
sa testy jednostkowe w test-editor-operations.scm.

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone - zmienic nazwe na "extract-from-box!"?

2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu pierwszego
     czyli:
     - merge-boxes!
     - merge-atoms!

4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
     - merge-texts!
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

1. insert! [lista do spacji]
   - wyodrebnic "insert-into-box!"
2. insert! [spacja do atomu]
   - rozbijamy atom na dwa - 
3. insert! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. insert! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. insert! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem



* 23.01.2023

Musimy dodac obsluge wstawiania spacji w spacje
do procedury insert!, jak rowniez obsluge pozostalych
sytuacji, takich jak:

- wstawienie znaku w Atom
- wstawienie znaku w Text
- wstawienie spacji/nowej linii w Atom
- wstawienie spacji/nowej linii w Text

Z pewnoscia chcemy tez napisac testy jednostkowe


* 22.01.2023

Mini-plan jest taki, zeby przeniesc funkcje
delete-forward!, delete-backward!, insert-character!
oraz delete! do primitive-terminal-client!
i dodac im przedrostek np. old!, tak zebysmy
mieli do nich dostep, ale zebysmy mogli zaczac
pisac nasze funkcje od poczatku.

Rzecz w tym, ze chcielibysmy, zeby te nowe funkcje
byly juz zaposredniczone w historii.

No ale. Plan na jutro rano jest taki, zeby:
- scommitowac zminy nazw z take-cell! na extract!
oraz ze splice! na insert!
- scommitowac przeniesienie funkcji z editor-operations
do primitive-terminal-client oraz nadanie przedrostka /old/
- zaczac pisac implementacje dla insert-character!
(i zmodyfikowac domyslna funkcje keymap tak, zeby
wywolywala insert-character!)


* 21.01.2023

No, to teraz mozemy radosnie
dodawac nowy ficzer edycji do GRASPa.

Najogolniej rzecz biorac, chcemy, zeby
wcisniecie klawisza powodowalo domyslnie
wywolanie 

(insert-character! (unicode-input) 
             into: (the-document) 
               at: (the-cursor))

gdzie:
- jezeli input to lewy nawias i jestesmy na spacji,
tworzymy nowe pudelko
- jezeli input to prawy nawias i jestesmy na lewym nawiasie,
atomie albo spacji, to idziemy do nastepnego zamykajacego nawiasu

dosc obszerna analize do przetrawienia mamy napisana
6 stycznia.

najblizsze commit w poniedzialek; programowanie
na telefonie jest duzo dostepniejsze, ale
na laptopie komfort pisania jest nieporownywalnie
lepszy.

OK, to z takich bardziej podstawowych rzeczy:
- chcemy zmienic nazwy z take-cell! na extract!
i ze splice! na insert!
(nie do konca juz pamietamy, dlaczego chcemy,
ale mimo wszystko nadal chcemy?)

W kazdym razie nazwy zostaly juz zmienione.

No i co dalej?

Moze bysmy usuneli:
- primitive-terminal-client
- funkcje "delete-forward!", "delete-backward!"
  oraz "insert-character!" z (editor-operations),
  zeby je moc zaimplementowac od nowa?

Nooo, tyle ze tam juz jakas funkcjonalnosc jest.

Mozemy zatem albo przeprowadzic analize tego,
co juz mamy, albo - w oparciu o wczesniejsza analize
- zaprojektowac to, co powinnismy miec.

Co dziwne, wydaje sie, ze niektore rzeczy
dzialaja.

* 19.01.2023

pozostale dwa punkty ze wtorkowej listy odhaczone

* 18.01.2023

pierwsy punkt z wczorajszej listy odhaczony.
teraz nam pozostaje dodac extend-selection
(usuwajac tego przykrego enuma)

* 17.01.2023

zadania na dzis/jutro:
- przetestowac desktop-client na asusie
  (i ew. ponaprawiac)
- uzupelnic mapy klawiatury
- dodac (shift left) oraz (shift right) jako ekspansje selekcji
  
* 14.01.2023

zbudowalismy juz zalazki map klawiatur dla
trzech klientow

teraz bysmy chcieli usunac stare zdarzenia
z modulu pane, i zastapic je nowymi

- bedzie to wymagalo translacji kodu
  zdarzenia do odpowiedniej postaci
  (w tym ustawienia parametru (unicode-input)
  tam gdzie to stosowne)

  w przypadku kazdego klienta bedzie to trzeba
  robic inaczej, i dlatego nalezy ustalic jakas
  kolejnosc:
  - najpierw klient terminalowy
  - po nim klient androidowy
  - a na koncu klient desktopowy
    (ktotego i tak nie mamy na razie jak
    przetestowac)

natomiast plany dlugofalowe:
+ skonczyc ta refaktoryzacje
+ zaimplementowac edycje
+ obsluga komentarzy (renderowanie i nawigacja)
+ obsluga uzytych rozszerzen Kawy/rezygnacja z nieuzytych rozszerzen
+ ladowanie i zapisywanie plikow; podzial ekranu
+ zgloszenie na ELS
+ mechanizm rozszerzen
+ poszczegolne rozszerzenia + sukcesywny rozwoj API do rysowania
+ evisulator
+ edytor grafow
+ obsluga selekcji (kopiowanie, wklejanie, usuwanie, historia)
+ naprawianie bledow (w tym zwiazanych z drag&dropem)
+ prezentacja na ELS
+ pierwsze wydanie, 2 aplikacje w sklepie
+ zgloszenie na StrangeLoop
+ siec spolecznosciowa

+ SICP - GRASP edition
+ The Little Schemer - GRASP edition
  (i podobnie: The Seasoned Schemer, The Reasoned Schemer)
+ The Dream Machine - GRASP edition
+ The Way Things Work - GRASP edition

+ The Art of Metaprogramming in Scheme

ok, tosmy sobie odplyneli

teraz do roboty: zmieniamy sposob obslugi
klawiszy w kliencie terminalowym - ale trzeba
jeszcze pomyslec co z obsluga myszy/wskaznikow

ok, klient terminalowy juz obskoczony.
teraz jeszcze tylko zostaje androidowy i desktopowy.

na razie sie zajmiemy androidowym

ok, wyglada na to ze to tez sie udalo.


* 13.01.2023

Mamy sobie 3 klienty. I teraz dla tych
3 klientow bedziemy chcieli zbudowac
moduly (android-key-map) (desktop-key-map)
oraz (teminal-key-map).

* 12.01.2023

No dobra, to teraz - zeby byla jasnosc - zaczynamy
od uwspolnionego systemu obslugi zdarzen, w ktorym
bedzie tylko zdarzenie 'key-typed', a funkcje beda
definiowane w pliku init.scm.

Na razie nie robmy hierarchicznej obslugi, bo to
moze byc overengineering.

Dopiero jak to bedzie gotowe, zajmiemy sie 'wstawianiem
znakow', ze szczegolnym uwzglednieniem aspektu historii
/cofania.

* 11.01.2023

trzeba obmyslic strategie implementacji
nowego podsystemu wprowadzania

W androidzie mamy:
getKeyCode(), getScanCode(), getMetaState()


w androidzie chcemy zmienic podsystem zdarzen
tak zeby na razie po prostu wypluwal zdarzenie
do logow


(active-pointers) ::(list-of int)

(pointer-position index::int) ::Position

(unicode-input)::char

w KeyboardEvent z awt mamy metode getKeyChar,
ktora zwraca kod albo CHAR_UNDEFINED.

(define-mapping (key-handler key-code)::(maps () to: void)
  (lambda ()::void
    (and-let* ((c (unicode-input)))
      (insert-character! c))))

Jeszcze trzeba rozwazyc opcje dodawania trybow,
tak zeby mozna bylo przeslaniac sobie tablice znakow
w roznych kontekstach.


(define-type (KeyMap bindings: (maps (key::int) to: () to: void)
                     parent: KeyMap))
      
* 10.01.2023

Wczorajszybi dzisiejszy dzien to glownie
walka z ewaluacja w kliencie androidowym
(i to trzeba odnotowac)


Jutro j pojutrze beda comity:
- ocpowiedziec na issue
- commitnw grasp-android

- zarchiwizowac grasp-android
- scomitowac zmiany tutaj

Na razie plan jest taki, ze chcemy
ujednolicic konfiguracje po stronie
androida, terminala i awt, szukajac
najwiekzzsgo wxpolnego mianownika

nastepnie bysmy te konfiguracje
przeniesli do init.scm

nastepnie bysmy juz zaczeli walke
z podpinaniem funkcji do edycji
dokumentu

fajnie by bylo to zrobic do konca
stycznia - i jeszcze obsluge
komentarzy w rendererze, oraz
otwieranie i zapisywanie plikow
oraz podzial ekranu

na pewno tez troche pracy bedzie
trzeba poswiecic zeby dopiescic
klienta awt

na dalszy ogien idzie mechanizm
rozszerzen oraz ewaluacja wyrazen
roraz juz partykularne rozszerzenia
(Img src: ...), wizualny ewaluator,
edytor grafow, chmura punktow

natomiast priorytetem powinno
byc doproeadzenie do sytuacji
w ktorej GRASP rozwijamy w GRASP,
a nie w Emacsie

----------------------------------

ok, to co teraz robimy?

trzeba bedzie rozehrac zdarzemia
z awt na kawalki

moze warto zrobic tabelke

|---------+------------+-------------+-----------|
| system  | press      | release     | type      |
|---------+------------+-------------+-----------|
| AWT     | keyPressed | keyReleasee | keyTyped  |
|---------+------------+-------------+-----------|
| Lantrna |            |             | readInput |
|---------+------------+-------------+-----------|
| Android | onKeyDown  | onKeyUp     |           |
|---------+------------+-------------+-----------|

Ok, i teraz co?

Teraz musimy odwzorowac klawisze i sekwencje
w ich nazwy. Na przyklad

(on-key '(ctrl alt shit x) cut-selection!)

czy cos

i teraz bysmy sobie zrobili takie cos,
ze tlumaczylibysmy sekwencje na wartosc
typu long, i systemy zdarzen w poszczegolnych
klientach robilyby to samo - i mielibysmy
tablice haszujaca, ktora mapuje nam
klawisze na odpowiednie procedury

Poniewaz jednak nie chcemy tracic
dotychczasowej funkcjonalnosci,
moze wypiszmy sobie jakie do tej porg
mielismy wiazania w poszczegolnych
klienach:

** klient terminalowy:

  (set! (on-key-press KeyType:ArrowLeft)
	(lambda ()
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowRight)
	(lambda ()
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowUp)
	move-cursor-up!)

  (set! (on-key-press KeyType:ArrowDown)
	move-cursor-down!)

  (set! (on-key-type #\x) exit)

** klient desktopowy

  (set! (on-key-press KeyEvent:VK_LEFT)
	(lambda _
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_RIGHT)
	(lambda _
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_UP)
	move-cursor-up!)

  (set! (on-key-press KeyEvent:VK_DOWN)
	move-cursor-down!)

  (set! (on-key-press KeyEvent:VK_Z)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:undo!)))))

  (set! (on-key-press KeyEvent:VK_Y)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:redo!)))))

** klient androidowy:

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_LEFT)
      (lambda _
	(move-cursor-left!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_RIGHT)
      (lambda _
	(move-cursor-right!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_UP)
      move-cursor-up!)

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_DOWN)
      move-cursor-down!)


* 09.01.2023

wyglada na to, ze mamy takie problemy
implementacyjne:
- w wersji skompilowanej, init.scm musi
  ladowac moduly, z ktorych korzysta
- ale trzy klienty beda musialy definiowac
  on-key na swoj sposob
- ale czy rzeczywiscie?

Definicja on-key bedzie taka sama, tylko
sposob wywolania bedzie rozny.

Teraz trzeba:

- usunac key-pressed! i key-released! z (panel),
  moze tez zmienic nazwe na (pane)

- zrobic jakos tak, zeby wywolywac odpowiednia
  funkcje dla kazdego klienta

* 08.01.2023

plan jak na razie wyglada zacnie.

jego realizacje zaczelibysmy od tego, ze kazdy
klient wykonywalby plik init.scm - na poczatku
to moze byc po prostu wypisanie loga albo cos.

co wiecej, zmiany w kliencie desktopowym
i terminalowym mozemy robic na laptopie

* 07.01.2023

Usunelismy funkcje "insert!", ale jest pewien
problem z testowaniem - na telefonie mozemy
jedynie przetestowac dzialanie aplikacji
na telefon.

Poza tym jest jeszcze kwestia taka, ze chcielibysmy
zbudowac przenosny interfejs wwjscia/wyjscia
pomiedzy klientami - cos w rodzaju

(on-key '(ctrl z) undo!)

(on-key '(ctrl y) redo!)

i wowczas bysmy sobie zdefiniowali:

(on-key 'space insert-space!)

(on-key 'backspace delete-backward!)

(on-key 'delete delete-forward!)

(on-key 'enter insert-newline!)

(on-key 'left move-cursor-left!)

(on-key '(shift left) expand-selection-left!)

(on-key 'right move-cursor-right!)

(on-key '(shift right) expand-selection-right!)

Mielibysmy tez takie funkcje:

(active-pointers) ::int

(pointer-position index::int) ::Position

(unicode-input)::char

Bedziemy chcieli miec plik init.scm, zawierajacy
powyzsze definicje.

Od strony implementacyjniej bysmy chcieli miec:
- bezposrednia tablice
- tablice shift dla klawiszy sterujaych
- tablice ctrl
- tablice alt
- tablice ctrl+alt
- tablice ctrl+shift
- tablice alt+shift
- tablice ctrl+alt+shift

Albo nawet nie. Moze byc jedna tablica.

* 06.01.2023

Idealnie byloby, gdybysmy nie dodawali
zadnych nowych operacji, tylko poprzestali
na Move, Remove oraz Insert.

Dzielenie atomu odbywaloby sie na zasadzie
wstawienia spacji w atom, laczenie - na zasadzie
usuniecia spacji itd.

Trzeba to bedzie sobie rozpisac.
Move -> take-cell!, splice!
Remove -> take-cell!
Insert -> splice!

Trzeba bedzie pozmieniac nazwy:
1. insert! z modulu (history) na cos (to trywialna
   funkcja uzyta w jednym miejscu w (panel))
2. ze splice! na insert!
3. z take-cell! na extract!

I teraz: funkcje (nowe) insert! i extract!
bedziemy musieli zmienic tak, zeby dzialaly
w roznych konfiguracjach

(docelowo do extract! bedziemy chcieli
jeszcze dodac argument numeryczny, tak
zeby moc uzywac tej funkcji do obslugi
selekcji, zas splice! rowniez bedzie
trzeba do tego celu przysposobic)

No dobra, ale teraz chyba bedzie trzeba
rozwazyc

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone: wydobywamy element
     z wnetrza pudelka
2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden3. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu
     pierwszego
4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

i teraz insert! analogicznie:

1. splice! [lista do spacji]
   - juz obsluzone (wklejamy liste pomiedzy element
     poprzedzajacy spacjena kolejny element)
2. splice! [spacja do atomu]
   - rozbijamy atom na dwa
3. splice! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. splice! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. splice! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem

1. extract-tile! at: Cursor from: document
   splice-list! list at: Cursor into: document
2. merge-atoms! at: Cursor in: document
   split-atom! at: Cursor in: document
3. merge-boxes! at: Cursor in: document
   split-box! at: Cursor in: document
4. merge-texts! at: Cursor in document
   split-text! at: Cursor in: document
5. remove-characters! at: Cursor from: document
   insert-charactets! at: Cursor into: document
   
* 02.01.2023

Dwie pierwsze zmiany w nowym roku:
- archiwizacja grasp-android
- odpowiedziec na "issue" w nowym repo

Natomiast to, czym teraz bysmy sie chcieli
zajac, to edycja dokumentow z klawiatury,
czyli:

- jak piszemy [, to tworzymy nowe puste pudelko
- jak piszemy ]. to wychodzimy z pudelka

W kazdym razie to sie dzieje w kontekscie
pudelek - bo w przypadku Textu dla niesterujacych
znakow zawsze owe znaki dopisujemy (pewnym wyjatkiem
moze byc \, ale to jeszcze trzeba przemyslec)

- jak piszemy ", to tworzymy nowy Text

jak wciskamy znak drukowalny, to:
- jezeli jestesmy na spacji, to tworzymy
  nowy atom
- jezeli jestesmy na atomie, to dopisujemy
  znak

Wyjatki:
- wcisniecie spacji, gdy jestesmy na spacji,
  dodaje spacje pozioma
- wcisniecie entera dodaje spacje pionowa
- wcisniecie spacji albo entera na atomie
  powoduje rozbicie atomu (chyha ze jestesmy
  na ostatniej pozycji - wtedy edytujemy
  nastepujaca spacje)

Trzeba bedzie zaczac od napisanis testow
dla takiego czegos, oraz dodac odpowiednie
operacjendo historii edycji

Rowniez chcielibysmy obsluzyc dzialanie
klawisza backspace.

Jezeli idzie o historie, to mozemy zamodelowac:
- rozszczepienie atomu jako wstawienie spacji
- scalenie atomu jako usuniecie spacji

Dzieki temu nie musimy dodawac nowych operacji
do historii.

Mamy zatem do dodania nastepujace operacje:
