* 08.04.2023

napisalismy test, ktory jednakowoz nie przechodzi.

problem chyba jest taki, ze procedura extract!
dla nie-komentarzy dodaje szerokosc wyrazenia
do spacji, natomiast procedura insert! dla
komentarzy juz tego nie robi

* 07.04.2023

no dobra. mamy hipoteze dotyczaca tego, jak powinna
dzialac nasza operacja. teraz zostaje nam jeszcze
przetestowanie tych operacji, dodanie ich do interfejsu,
i dodanie testu do operacji edycji

a do tego chcemy dodac nowe metody paintera
do grasp-desktop i grasp-android

a pozniej co?

- quote'y
- scrollowanie
- podzial ekranu
- ladowanie plikow

a pozniej co?

- ewaluacja
- rozszerzenia
- partykularne rozszerzenia
- sklep + wersja platna
  
* 06.04.2023

test wykazal, ze trzeba jeszcze troche dopiescic
insercje. i to bysmy zrobili, plus:
- dodali operacje historyczne
- zaimplementowali w kliencie desktopowym i androidowym


(define (f x y) z)

(the-expression at: '(5 3 1 1)) ===> y

(define (f x #;y) z)

(the-expression at: '(2 4 3 1 1)) ===> #;y


(define-type (CommentExpression at: Cursor following: int)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* ((`(,expression) (take! at: at from: document))
              (`(,tip . ,root) at)
	      (cursor (recons* following (- tip 1) root)))
     (insert! (ExpressionComment expression: expression)
              into: document at: cursor)
     cursor))
  ((inverse)::Edit
   (and-let* ((`(,tip . ,root) at))
     (UncommentExpression at: (recons* following (- tip 1) root)))))
     
(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* (((ExpressionComment expression: expression)
               (take! at: at from: document))
	      (`(,tip ,top . ,root) at))
     (insert! (cons expression '()) at: at into: document)
     (recons (+ top 1) root)))
  ((inverse)::Edit
   (and-let* ((`(,tip ,top . ,root) at))
     (CommentExpression at: (recons (+ top 1) root)
                        following: tip))))

* 05.04.2023

mamy niby napisany insert dla komentarzy,
ale trzeba jeszcze napisac testa.

* 04.04.2023

wyglada na to ze mamy awarie karty pamieci
i nasz projekt quote'ow wzial w leb

no to co teraz:
- insert!
- operacje historyczne
- integracja z interfejsem
- implementacje w edytorach graficznych

  ok to zacznijmy od analizy inserta

* 01.04.2023 (telefon)

Extract! juz jest zrobiony.
Teraz co jeszcze musimy zrobic:
- insert! dla komentarzy
- CommentExpression i UncommentExpression
- renderowanie wykomentowanych wyrazen
  - jako tekst
  - w terminalu (ciemniejszy kolor)


* 27.03.2023

pomysl jest taki, zeby zrefaktoeyzowac
funkcje "extract!" - tak zeby mogla zwracac
albo pare, albo separator, albo komentarz.

No, ale w tym celu musimy najpierw
przeanalizowac dotychczasowe dzialanie
tej funkcji, bo jest tak, ze rozne byly
zachowania w zaleznosci od tego,
ktory element zesmy ekstrahowali.

Rownolegle - poniewaz rysowanie gestow
zdaje sie pomagac w diagnozie - warto
poprawic klienta desktopowego

To moze przeanalizujmy architekture:

mamy screen-renderer, implementujacy
Paintera i bedacy JComponentem,
unterfejs InputListener agregujacy
rozne event handlery, oraz InputHandler,
rozszerzajacy JFrame i dostarczajacy
trywialnych implementacji.

Wreszcie jest window-screen, ktory rozszerza
InputHandler, dostarczajac nietrywialnych
implementacji handlerow tam gdzie trzeba.

I teraz plan jest taki, zeby window-screen
nie dziedziczyl po JFrame, tylko zebysmy
tworzyli JFrame, na ktorym bysmy
wywolywali setContentPane

No dobra. A co z tym naszym extractem?

* 27.03.2023 (komputer)

Master plan: window-screen powinien byc JComponentem,
run-in-AWT-window powinno tworzyc javax.swing.JFrame,
ktorego content-pane: to bedzie wlasnie window-screen.

Tylko kilka uwag:

- window-screen to nie jest dobra nazwa, i trzeba
wymyslic inna

- byc moze warto sie zastanowic nad scaleniem ze soba
tej klasy ze screen-rendererem

* 26.03.2023

(define/kw (fully-expanded? cursor::Cursor
             on: document := (the-document))::boolean
  (and-let* ((`(,tip . ,root) cursor)
             (target (cursor-ref document root)))
    (eq? target (part-at tip target))))

(define (cursor-trace document cursor)
  (match cursor
    ('() (cons document '()))
    (`(,tip . ,root)
     (and-let* ((trace (cursor-trace document tail))
                (`(,parent . ,elders) trace))
	(cons (part-at tip parent) trace)))))

no dobra. i teraz co?


* 25.03.2023

1. Wykomentowywanie wyrazen
dwie nowe operacje:

(define-type (CommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((preceding-cursor (cursor-retreat at document))
              (`(,item::Tile) (extract! at: at from: document)))
     (insert! (ExpressionComment expression: item)
              into: document at: preceding-cursor)
     preceding-cursor))
  ((inverse)::Edit
   (UncommentExpression at: ???)))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((
  ((inverse)::Edit
   (CommentExpression at: ???)))

Aczkolwiek problem jest taki, ze extract!
nie obsluguje komentarzy.

To pomysl jest teraz taki, zeby
- albo dodac obsluge komentarzy
  do 'extract!' (ktorej to funkcji
  jednak nie lubimw)
- albo po prostu po chamsku
  samemu wyciagnac z komentarza


A gdybysmy tak mieli napisac extract! drugi raz?

* 24.03.2023

zmiana rozmiaru dziala w miare OK.

to teraz skupilibysmy sie na takich
tematach:
- rysowanie kresek
- wykomentowywanie wyrazen
- poprawne dzialanie drag&drop na komentarzach?

Dobra, zacznijmy od tego rysowania kresek.

(define-object (Drawing stroke::Stroke)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    (stroke:add (Point x y)))
    
  (define (drop! x::real y::real vx::real vy::real)::void
    (the-overlay:removeIf (is _ Stroke?)))

  (the-overlay:add! stroke))

No, to rysowanie kresek juz jako tako dziala.
Wprawdzie jest jeszcze sporo do przemyslenia,
ale juz sie troche nie moge doczekac poniedzialkowego
commita.

No dobra, i co dalej?

Kolejna rzecz jaka mozemy robic, to:

- wykomentowywanie wyrazen
- poprawki w edycji komentarzy
- drag&drop na komentarzach


* 23.03.2023

Dzisiaj:
- naprawilibysmy buga zwiazanego ze zmiana rozmiaru
  pudelka w ktorym znajduje sie linia zakonczona
  komentarzem
- dodalibysmy mozliwosc rysowania kresek

Ale warto sie zastanowic czy nie lepiej
byloby ujednolicic reprezentacje spacji w taki
sposob, zeby nowa linia pojawiala sie explicite.

Do przemyslenia (choc tak po prawdzie to pewnie
raczej nie, bo wydaje sie, ze jestesmy dosc blisko
funkcjonujacego kodu)

Wyglada na to, ze bedzie trzeba troche popracowac :/

* 22.03.2023

Dzis bysmy sprobowali przemyslec co jest
do zrobienia w kontekscie poszczegolnych
klientow (terminalowego, desktopowego
i androidowego), a jaka kompetencje powinien
miec (pane), jezeli idzie o rysowanie gestow.

I takie pytanie: czy moglibysmy zaimplementowac
rysowanie gestu jako 'Drag'?

(define-object (DrawingGesture gesture::Gesture)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    ;; dodajemy Point do stroke'a
    ...)
    
  (define (drop! x::real y::real vx::real vy::real)::void
    ;; wywolujemy recognizer
    ...)

  (the-overlay:add! gesture))

* 21.03.2023

Przeanalizujmy obsluge gestow w grasp-android:

mamy globalny obiekt

(define the-stroke ::Stroke #!null)
(define the-gesture ::Gesture (Gesture))

oraz funkcje 'isShapeBeingDrawn'

(define (gesture-is-being-drawn?)::boolean
  (isnt the-stroke eq? #!null))

a do tego funkcje

(define (start-drawing-gesture!)::void
  (set! the-stroke (Stroke)))

(define (cancel-drawing-gesture!)::void
  (gesture:clear!)
  (set! the-stroke #!null))


no i dobrze. ale ciekawsze jest to, w jaki sposob
te funkcje sa wywolywane:

cancelDrawingShape jest wolany w:
-onDoubleTap
-onDown (gdy przycisnieto drugi palec
albo gdy onPress zwrocilo obiekt Drag)
-onMotion gdy wygenerowano DoublePress
-onUp jezeli udalo sie rozpoznac gest
-onSingleTap
-onLongPress

z kolei startDrawingShape jest uzywany
w onDown (jezeli nic innego sie nie wydarza)

wreszcie isShapeBeingDrawn jest:
- w onDown przy sprawdzaniu czy przycisnieto
  drugi palec i przy rozpoczynaniu rysowania
  ksztaltu
- w onMotion przy dodawaniu nowego odcinka
  do aktualnego stroke'a
- w onUp przed rozpoczeciem rysowania
  

natomiast finalizeStroke jest wywolywany przy
konczeniu rysowania

* 20.03.2023

Rysowanie gestow
ma dwojaki sens:
- czlowiek rysuje gesty
- program rysuje linie

No ale dobra
trzeba pomyslec
w jaki sposob chcemy
reprezentowac.

Teraz w (pane) mamy cos, co sie nazywa overlay,
i do czego mozemy wlozyc obiekty Drawable.

i teraz: chcielibysmy miec obiekt "Drawable",
ktory bylby dodawany do Overlay w momencie,
kiedy zaczynamy cos rysowac.

ale jak sie on bedzie nazywal?

    
* 19.03.2023

teraz to bysmy chcieli miec funkcje

(define 4pix-code
  (let ((4pix (mapping (4p::char)::int 0)))
(set! (4pix #\space) #b0000)
(set! (4pix #\▘) #b0001)
(set! (4pix #\▝) #b0010)
(set! (4pix #\▀) #b0011)
(set! (4pix #\▖) #b0100)
(set! (4pix #\▌) #b0101)
(set! (4pix #\▞) #b0110)
(set! (4pix #\▛) #b0111)
(set! (4pix #\▗) #b1000)
(set! (4pix #\▚) #b1001)
(set! (4pix #\▐) #b1010)
(set! (4pix #\▜) #b1011)
(set! (4pix #\▄) #b1100)
(set! (4pix #\▙) #b1101)
(set! (4pix #\▟) #b1110)
(set! (4pix #\█) #b1111)
4pix))

(define 4pix ::char[]
  (char[]
  #\space
  #\▘
  #\▝
  #\▀
  #\▖
  #\▌
  #\▞
  #\▛
  #\▗
  #\▚
  #\▐
  #\▜
  #\▄
  #\▙
  #\▟
  #\█
  ))

(define (4pix-set! x4::int y4::int)::void
  (let* ((x ::int (quotient x4 2))
         (h ::int (remainder x4 2))
         (y ::int (quotient y4 2))
	 (v ::int (remainder y4 2))
	 (c ::char (get y x))
	 (existing-code ::int (4pix-code c))
	 (mask ::int (arithmetic-shift 1 (+ (* 2 v) h)))
	 (new-code ::int (bitwise-ior existing-code mask))
	 (c* ::char (4pix new-code)))
    (put! c* y x)))


x^2 + y^2 = r^2

y^2 = r^2 - x^2

y = sqrt(r^2 - x^2)


(x0 - radius + i)


(define (draw-circle-4pix! x0::real y0::real radius::real)::void
  (let ((diameter ::int (ceiling (* 2 radius)))
        (r^2 (* radius radius)))
    (for i from 0 to diameter
      (let* ((dx ::real (- i radius))
             (dy :: real (sqrt (- r^2 (* x x))))
	     (x ::int (as int (round (+ x dx))))
	     (+y ::int (as int (round (+ y dy))))
	     (-y ::int (as int (round (- y dy)))))
        (4pix-set! x +y)
        (4pix-set! x -y)))))

    
* 18.03.2023


x1-x0   y1-y0
----- = -----
  m       n

y0 = ax0 + b
y1 = ax1 + b


(define (draw-line! x0::real y0::real x1::real y1::real)::void
  (let* ((x1-x0 ::real (- x1 x0))
         (y1-y0 ::real (- y1 y0))
	 (angle ::real (atan y1-y0 x1-x0)))
    (cond
      ((is -pi/4 <= angle <= pi/4) ;>>
       (let ((slope ::real (tan angle))
             (x0 ::int (round x0)))
         (for i from 0 to (as int (ceiling x1-x0))
	   (let ((x (+ x0 i))
	         (y (+ y0 (* slope i))))
             (put! #\█ (as int (round y)) x)))))
      ((is pi/4 <= angle <= (* 3 pi/4)) ;>>
       (let ((slope ::real (/ (cos angle) (sin angle)))
             (y0 ::int (round y0)))
         (for j from 0 to (as int (ceiling y1-y0))
	   (let ((x (+ x0 (* slope i)))
	         (y (+ y0 i)))
	   (put! #\█ y (as int (round x))))))
      (else
       (draw-line! x1 y1 x0 y0)))))


▞▚
▚▞

  ▄
 ▞ ▚
▐   ▌
 ▚ ▞
  ▀

▖▗ ▘▝
  
 ▗▀
▐   ▌
 
  ▀
* 17.03.2023 (telefon)

W ramach odpinki moze sprobujemy dodac do systemu
funkcjonalnosc rysowania gestow.

Ogolnie to musi wygladac tak, ze
jak zaczynamy rysowac gest, to dodajemy
'stroke' do overlaya, natomiast sam 'stroke'
to nic innego jak lista punktow.

Na pozor wydaje sie to latwe, ale pamietajmy
takze o tym, ze chcemy tez rysowac linie
w terminalu - i dlatego chcielibysmy dodac
mozliwosc rysowania linii do interfejsu Painter.

(mozna sie tez zastanowic nad uzyciem
w GRASP renderowania w stylu Figlet)

Oczywiscie rysowanie linii trzeba zaimplementowac
dwojako: w kliencie tekstowym i terminalowym.

W przypadku klienta terminalowego bedziemy
uzywac koloru, natomiast w przypadku klienta
tekstowego bysmy uzyli tego:

▞▀▀▀▚
▌    ▌
▚    ▐
 ▚   ▞
  ▚▄▞

▛▜
▙▟ █
  
czyli dodajemy do paintera funkcje

(draw-line! x1::real y1::real x2::real y2::real)::void

i implementacje dla androida i awt (wolajace
pod spodem odpowiednie funkcje) oraz dla klienta
tekstowego

* 14.03.2023

Popsute klikniecia udalo sie naprawic, i powinny wyjsc
w jutrzejszej serii commitow.

Natomiast teraz chcemy sie zajac nastepujacymi rzeczami:
- dodawanie, usuwanie i edycja komentarzy blokowych
(poprzez wpisanie #| albo |# w kontekscie atomu - wowczas
powinnismy podzielic atom, np. ab#|cd powinno nam zrobic
dwa atomy ab cd, a miedzy nimi pusty komentarz blokowy)

tak naprawde to wcisniecie | powinno dzialac w taki sposob,
ze jezeli jestesmy na przedostatnim elemencie listy, to
sprawiamy, ze ta lista bedzie "dotted?". Jezeli natomiast
jestesmy na symbolu i po lewej albo prawej stronie
od kursora znajduje sie znak #, to go usuwamy
i wstawiamy komentarz blokowy (i przy okazji byc moze
rowniez rozbijamy atomy)

Wydaje sie, ze dodatkowo bedziemy chcieli zrobic
nowy rodzaj operacji edycji, ktory sobie nazwiemy
"EditSequence", o taki mniej wiecej

#+BEGIN_SRC scheme
(define-type (EditSequence operations:  (list-of Edit))
  ((apply! document)::Cursor
   (let ((result ::Cursor #!null))
     (for operation in operations
       (set! result (operation:apply! document)))
     result))
  ((inverse)::Edit
   (define (transform sequence inverted)
     (match sequence
       (`(,head::Edit . ,tail)
        (transform tail (cons (head:inverse) inverted)))
       ('()
        inverted)))
   (transform operations '())))
#+END_SRC

* 12.03.2023

Wyglada na to, ze biezaca implementacja komentarzy
blokowych popsula zupelnie detekcje klikniec.

* 09.03.2023

Do zrobienia mamy:
- usuwanie komentarzy
- chyba poprawki w inwersji dodawania komentarzy?
- renderowanie komentarzy blokowych
- edycja komentarzy blokowych
- dodawanie i usuwanie komentarzy blokowych

No dobrze, uznajmy komentarze liniowe za skonczone
(choc niewatpliwie trzeba sie jeszcze bedzie uporac
z bugami i roznymi corner case'ami, ktore jedak
na razie nie sa naszym priorytetem)

To teraz robimy komentarze blokowe.
Renderowanie musi tak przebiegac,
ze rysujemy prostokat, a wewnatrz
renderujemy tekst


* 08.03.2023

Wczoraj napisalismy funkcje do dodawania komentarzy
do spacji, oraz test dla niej.

Dzis bysmy sprobowali zintegrowac te funkcje z edytorem,
tak zeby wcisniecie srednika powodowalo dodanie komentarza
- aczkolwiek do tego bedzie jeszcze konieczne dodanie 
operacji odwrotnej, tj. usuniecie komentarza

* 07.03.2023

Dzis bysmy sie zajeli edycja liniowych komentarzy.

W kolejce czeka jeszcze kilka pomniejszych rzeczy,
takich jak:
- naprawa polozen kursora na spacjach
- renderowanie lewej belki przy liniowych komentarzach
- renderowanie cudzyslowow przy stringach
- obsluga drag&dropa przy rysowaniu stringow i komentarzy

Ogolnie plan jest taki, ze najpierw skonczymy edycje
liniowych komentarzy, pozniej zrobimy pudelkowe
komentarze, a na koncu wyrazeniowe komentarze.

Kiedy to bedzie zrobione, zajmiemy sie quote'ami itd.
(oraz moze syntaxami itd.?),

a dalej bysmy zrobili to ladowanie i zapisywanie
i scrollowanie i dzielenie ekranu (ach jakie to bedzie
piekne)

i wowczas dalsze rzeczy bedziemy juz robic w samym
GRASPie! (jupi!)

No ale dobra. Teraz robimy edycje komentarzy.
Powinno to dzialac tak mniej wiecej:
1. jezeli jestesmy na spacji i wcisniemy ;,
to dodajemy do tej spacji nowy liniowy komentarz
(i odpowiednio przesuwamy kursor)
2. jezeli od tego miejsca nacisniemy na (pustym)
komentarzu backspace, to usuwamy komentarz
3. jezeli nacisniemy "delete" na poczatku komentarza,
to usuwamy caly komentarz
4. jezeli wciskamy na zwykly klawisz, to po prostu
   dopisujemy odpowiedni znak do komentarza
5. jezeli mielibysmy dopisac znak nowej linii,
   to dzielimy komentarz

To ostatnie bedzie najpewniej wymagalo zaimplementowania
interfejsu Textual w LineComment

Trzeba bedzie dodac nowe operacje: 
(InsertComment content: TextualComment at: Cursor)

oraz

(RemoveComment content: TextualComment at: Cursor)

a takze

(CommentExpression at: Cursor)

oraz

(UncommentExpression at: Cursor)


* 06.03.2023

Dzisiaj musimy tak zmodyfikowac cursor-under* w Space,
zeby dawal poprawne indeksy podczas iterowania
(zeby klikanie na komentarze umieszczalo kursor
w odpowiednim miejscu)

Ponadto mozna by cos pokombinowac, zeby kursor
znajdujacy sie normalnie na spacji byl na takiej
samej wysokosci, co liniowy komentarz, jezeli
za nim znajduje sie liniowy komentarz.

No dobrze. To "Space::cursor-under*" powinien
sie zachowywac analogicznie do "advance!".

Wyglada na to, ze w pierwszym wierszu
komentarza wszystko dziala jak nalezy
- ale ze w drugim wierszu juz nie udaje
sie zlapac.

To sie chyba udalo jakos naprawic.

** Problem z generic-dispatch i subclassigniem

Przy okazji - problem, ktory pojawia sie, gdy mamy
"generic dispatch" oraz "subclassing" - i jest to
problem zasadniczo nierozwiazywalny:

(define-class <a> ())

(define-class <b> (<a>))

(define b (make <b>))

(define-class <c> (<a>))

(define c (make <c>))

(define-method (m (x <a>) (y <a>)) 'aa)
(define-method (m (x <b>) (y <a>)) 'ba)
(define-method (m (x <a>) (y <c>)) 'ac)

(m b c)

* 05.03.2023

W najblizszym czasie - w zwiazku z implementacja
komentarzy liniowych - bedziemy mieli do zrobienia
takie oto prace:
1. zeby klikanie na ekranie powodowalo umieszczenie
kursora w odpowiednim miejscu
2. zeby pisanie powodowalo dodawanie tekstu do komentarza
3. zeby komentarze mozna bylo przeciagac i upuszczac
4. zeby upuszczenie pudelka nad komentarzem powodowalo
   jego serializacje? (ale wtedy chyba to samo chcielibysmy
   dla stringow, c'nie?)


* 03.03.2023

Chyba z rysowaniem komentarzy udalo sie juz jakos dojsc
do ladu.

Ale teraz z kolei mamy inny problem:

kiedy kursor jest we wlasciwej czesci dokumentu, to nie dochodzi
do rysowania go.

* 02.03.2023

Wyglada na to, ze mamy problem z przypisywaniem indeksow
podczas rysowania spacji.

No to w takim razie przeanalizujmy sobie

Mamy 3 interesujace metody w Space:
1. draw!
2. advance!
3. cursor-under*

No i dobra, i teraz rozwazmy sobie te metode
draw!.

Ona robi tak, ze definiuje sobie wewnetrzna petle,
ktora "zjada" fragmenty spacji i sledzi wartosc "total".

I teraz tak: czym jest ow parametr "total"?

Pierwotna interpretacja byla taka, ze jest to
informacja o tym, ile spacji udalo sie juz przeskoczyc.

Mamy jednak przed soba kilka trundych kwestii:
- nie wiemy, czy poprzednia interpretacja w ogole byla dobra
- nie wiemy, jaka powinna byc nowa interpretacja

No, wezmy sobie

(Space fragments: (list 2 LC 2 LC))

Dziala to tak, ze najpierw total wynosi 0. Nastepnie:
- wywolujemy (advance-with-cursor! width) i dodajemy
width do total
- nastepnie mamy LC. Ono powinno byc na indeksie 3
kolejna 2 


** a to takie tam bazgrolki:

︴
︴

⌇
⌇
⌇

╭  ╮
︴ ︴ 
︴ ︴
︴ ︴
╰

⸾        ╭         ╮      ⌇
⸾ define ┆ map f l ┆      ⌇
⸾        ╰         ╯      ⌇
⸾ ⸾                     ╮ ⌇
⸾ ⸾ match l             ┆ ⌇
⸾ ⸾                     ┆ ⌇
⸾ ⸾ ⸾ ┏  ┓ ┏  ┓ ╮       ┆ ⌇
⸾ ⸾ ⸾ ┇  ┇ ┇  ┋ ┆       ┆ ⌇
⸾ ⸾ ⸾ ┗  ┛ ┗  ┛ ╯       ┆ ⌇
⸾ ⸾ ⸾ ╓      ╥      ╖ ╮ ┆ ⌇
⸾ ⸾ ⸾ ┋ head ┋ tail ┋ ┆ ┆ ⌇
⸾ ⸾ ⸾ ╙      ^      ╜ ╯ ╯ ⌇


⸾   ⌇  
⸾   ⌇
⸾   ⌇


⏭ ⏮ ⏯
⏴⏵⏶⏷⏸⏹⏺

* 01.03.2023

Wczoraj nie udalo sie osiagnac zbyt wiele - ale mimo
wszystko cos sie udalo!

Dzis zajelibysmy sie pisaniem staromodnych testow
dla "space-fragment-index", "delete-space-fragment!",
"Space:last-index", oraz zaimplementowalibysmy
w LineComment interfejs Textual
(ogolnie chcielibysmy zeby BlockComment takze
obslugiwal ten interfejs - ale ExpressionComment
juz niekoniecznie)

No ale dobra: rzecz ma sie tak, ze:
- wystapienie LineComment powodje pojawienie
  sie nowej linii (czyli tak jak pojawienie sie
  dwoch liczb po sobie)
- ale wystapienie BlockComment czy ExpressionComment
  juz niekoniecznie

Ale teraz jak to ogarnac?

Mamy takie operacje:
- rysowanie
- mierzenie
- klikanie

Poniewaz na razie rzecz wyglada nieco kiepskawo
jezeli idzie o diagnostyke, to zaimplementujemy
renderowanie komentarzy w kliencie desktopowym.

* 28.02.2023

Wczoraj z grubsza sie udalo zaimplementowac renderowanie
w kliencie tekstowym i terminalowym, ale nie mamy jeszcze
obslugi klikania, i strzalki w lewo i prawo tez jeszcze
nie calkiem dzialaja.

Dlatego dzis moze sprobowalibysmy sie zajac tymi dwiema
kwestiami.

* 27.02.2023

Do rozdzielenia juz doszlo, i wyglada na to,
ze niczego to nie psuje.

Teraz mamy dwa najistotniejsze watki:
1. zaimplementowac min-box-height na Androidzie
2. sprobowac dodac slowo kluczowe 'default
do domyslnych interfejsow, i usunac metode
"advance!" z implementacji Tile.

A w dalszej kolejnosci sprobowalibysmy pojsc
taka droga:
1. zaimplementowac komentarze liniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
2. zaimplementowac komentarze blokowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
3. zaimplementowac komentarze wyrazeniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
4. rozwazyc uzycie mechanizmu rozszerzen
  do wyswietlania quote, quasiquote, unquote, unquote-splicing
5. wprowadzic obsluge quote, quasiquote, unquote,
  unquote-splicing do parsera

No dobra, czyli teraz: komentarze liniowe dla klienta
terminalowego (i textowego)

To zaczynamy od tekstowego.
Bedzie trzeba dodac testy jednostkowe,
natomiast w przypadku terminalowego - jeszcze
ustawic kolory odpowiednio.

No dobra. Implementacja komentarzy musi sie skladac
z nastepujacych metod:
1. draw!
2. extent
3. cursor-under

* 24.02.2023

Teraz pomysl jest taki, ze poniewaz zakladamy,
ze linie skladajace sie tylko z komentarzy liniowych
moglibysmy ze soba scalac, moglibysmy rozdzielic
parametr "min-line-height" na "min-box-height"
i "min-line-height"

Gdzie jest uzywany min-line-height?

- W (extent '())
- w (empty-space-extent)
- przy inicjalizacji "traversal" jako max-line-height
  w traverse
- przy inicjalizacji obiektu Traversal w Space:extent
- w funkcji resize! do zmiany rozmiaru pudelka
- w metodzie new-line! obiektu Traversal
- w metodzie atom-extent w CharPainterze


* 23.02.2023

bysmy moze zaczeli od zaimplementowania
draw-line-comment! i draw-box-comment!
w painterze (tzn. w TextPainterze,
TerminalPainterze, screen-rendererze,
a w pozniejszym czasie rowniez
w androidowym View).

Dla TextPainter bysmy tylko robili

dla TerminalPainter bysmy tez dodali
troche koloru.

│ jeden srednik
┃ dwa sredniki
┣ trzy sredniki
┣━ cztery sredniki
┣━━ piec srednikow

Wreszcie dla screen-renderera - i docelowo
dla Androida tez - bysmy wybrali jakas
zwariowana czczionke

Jezeli idzie o komentarze pudelkowe,
to bysmy je tak rysowali:

┌───┐
│   │
└───┘

Lispiarze maja ogolnie taka konwencje, ze
;;; Heading
;;;; subheading
;;;;; subsubheading

No dobra, ale pozostaje nam jeszcze kwestia
tego, ze chcielibysmy, zeby komentarze liniowe
byly jedna linia pod druga, tzn. zeby nie bylo
miedzy nimi takiego duzego odstepu, jak w przypadku
atomow

* 22.02.2023

Wydaje sie, ze przynajmniej pozornie:
- dodanie rysowania do komentarzy bedzie
raczej proste
- dodanie "cursor-under*" wymaga nieco myslenia
- dodanie 'advance!' tez powinno byc raczej latwe

No to zastanowmy sie nad tym "cursor-under*"

Mamy sobie kopie obiektu traverse.
Funkcja "cursor-under" odejmuje t:left i t:top
od otrzymanych wartosci left i top.

Ale z jakichs wzgledow implementacja cursor-under*
w Space przywraca rame odniesienia dla danego
obiektu Traverse.

Ogolnie rzecz biorac to ma sens o tyle, ze
spacje nie sa "foremne" i moga rozciagac sie
na wiele linii.

No ale dobra. W przypadku spacji transformujemy
wspolrzedne z powrotem do ukladu wspolrzednych
obiektu (the-traverse).

To teraz zamysl jest taki:
1. implementujemy metody draw!, cursor-under* oraz advance!
   dla wszystkich trzech odmian komentarzy
2. integrujemy to sobie w obiekcie space
3. wszystko hula i sie cieszymy

No dobrze, ale mamy tak:

|---------------+--------------------+------------------------+--------------------------|
| metoda        | LineComment        | BlockComment           | ExpressionComment        |
|---------------+--------------------+------------------------+--------------------------|
| draw!         | rysujemy           | rysujemy               | najpierw rysujemy        |
|               | jakis znacznik     | pudelko wewnatrz       | spacje (mozemy sobie     |
|               | i renderujemy      | ktorego renderujemy    | zalozyc ze sa zerowe)    |
|               | tekst (ale trzeba  | tekst (trzeba pomyslec | a po nich wyrazenie      |
|               | pomyslec o kolorze | o kolorze i kroju      | - ale trzeba w jakis     |
|               | i kroju czcionki)  | czcionki)              | sposob zmienic tryb      |
|---------------+--------------------+------------------------+--------------------------|
| cursor-under* |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|
| advance!      | normalnie          | normalnie              | najpierw spaces:advance! |
|               |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|


Trzeba przemyslec jakie zmiany by nalezalo wprowadzic do paintera.

Moglibysmy po prostu dodac:

enter-comment-drawing-mode!
exit-comment-drawing-mode!

A co z cytowaniem?

increase-quotation-level!
decrease-quotation-level!

increase-quasiquotation-level!
decrease-quasiquotation-level!

No i jeszcze co ze zwyklymi komentarzami?

draw-line-comment!
draw-block-comment!

line-comment-extent
block-comment-extent


╭        ╭         ╮      ╮
│ define │ map f l │      │
│        ╰         ╯      │
│ ╭                     ╮ │
│ │ match l             │ │
│ │                     │ │
│ │ ╭ ┏  ┓ ┏  ┓ ╮       │ │
│ │ │ ┃  ┃ ┃  ┃ │       │ │
│ │ ╰ ┗  ┛ ┗  ┛ ╯       │ │
│ │ ╭ ╓      ╥      ╖ ╮ │ │
│ │ │ ║ head ║ tail ║ │ │ │
╰ ╰ ╰ ╙      ^      ╜ ╯ ╯ ╯


╭        ╭         ╮      ╮
┆ define ┆ map f l ┆      ┊
┆        ╰         ╯      ┊
┆ ╭                     ╮ ┊
┆ ┆ match l             ┆ ┊
┆ ┆                     ┆ ┊
┆ ┆ ╭ ┏  ┓ ┏  ┓ ╮       ┆ ┊
┆ ┆ ┆ ┇  ┇ ┇  ┋ ┆       ┆ ┊
┆ ┆ ╰ ┗  ┛ ┗  ┛ ╯       ┆ ┊
┆ ┆ ╭ ╓      ╥      ╖ ╮ ┆ ┊
┆ ┆ ┆ ┋ head ┋ tail ┋ ┆ ┆ ┊
╰ ╰ ╰ ╙      ^      ╜ ╯ ╯ ╯




* 21.02.2023

Dzis bysmy sie zajeli tym, zeby komentarze byly uwzgledniane
przy renderowaniu, rozmiaru wyliczaniu i myszki klikaniu.

I to wyglada tak, ze mamy sobie funkcje "traverse",
ktora wywoluje naprzemiennie zadana akcje oraz
metode advance! na obiekcie traversal.


W przypadku rysowania mamy item:draw!,
dla mapowania kursora mamy item:cursor-under*
natomiast przy wyliczaniu 'extent' nie mamy
zadnej akcji, ale mamy okreslona funkcje
zwracajaca.

I teraz: tutaj nic nie bedziemy zmieniac.

Musimy tylko zaktualizowac metody wewnatrz
Space:
- draw!
- cursor-under*
- advance! 

* 20.02.2023

No dobra, wydaje sie, ze edycje z klawiatury mamy
jakos tam zaimplementowana.

Moze finalnie bedzie trzeba wprowadzic jakas
dywersyfikacje dla delete-forward! i delete-backward!
(zeby kursor lepiej sie zachowywal)

No, ale teraz zajelibysmy sie juz innymi sprawami:
- po pierwsze, renderowaniem komentarzy (i to az w trzech
smakach) oraz nawigowaniem po komentarzach, edycja
komentarzy, ... (czyli mowiac krotko - edycja komentarzy)

- po drugie, obsluga kawowych rozszerzen skladniowych,
tak zebysmy mogli parsowac zrodla GRASP,
a przy okazji zajelibysmy sie obsluga rozszerzen
jako takich, tak zeby moc wyswietlac quote'y, 
unquote'y i quasiquote'y, a takze - skoro to juz jest
w jakiejs formie - to moze nasz guzik?

- po trzecie, bysmy wreszcie zrobili to otwieranie
i zapisywanie plikow, scrollowanie widokow oraz
podzial ekranu

- a po czwarte - przywrocilibysmy podsystem gestow

Pozostaje jeszcze kwestia naszego pejperu,
do ktorego chcielibysmy dopisac informacje o tym,
jak ma byc zaprojektowany system gestow,
oraz screenow z rysowania gestow.

No ale tak:
do interfejsu Painter dolozymy metody
-quasiquote!
-unquote!
-quote!
albo cos w tym rodzaju

Chodziloby o to, ze:
- teksty i nawiasy ktore nie sa owiniete w quote'a
  ani unquote-a rysujemy normalnie
- teksty i nawiasy owiniete w jednego quote'a rysujemy
  pogrubione
- teksty i nawiasy owiniete w jednego unquote'a
  rysujemy kursywa
  
Czy cos. Jakos to sprobujemy pomyslec.

Na razie jednak te komentarze.

Problem jest taki, ze:
- LineComment i BlockComment wymagaja (text)
- ExpressionComment wymaga (space)
- (text) wymaga (space)

Wydaje sie zatem ze moze rzeczywiscie
bedzie trzeba utworzyc jakis interfejs
ktory bedzie w (space), natomiast same
implementacje umiescimy gdzie indziej
(moze w (text) i (primitive))

Natomiast metody, jakich bedziemy potrzebowac,
to:
- print


OK, na razie udalo sie wyodrebnic modul z komentarzami.

I co chcemy dalej?

No, dalej to z pewnoscia chcemy wyswietlac
te komentarze, uwzgledniac je przy wyliczaniu
rozmiarow i przy klikaniu kursorem

Co wiecej: w kliencie terminalowym chcielibysmy
wyswietlac komentarze w ciemniejszym kolorze,
zas w klientach graficznych uzyc do tego celu
jakiejs smiesznej czcionki.

I moze tym bysmy jutro sie zajeli, a pozniej
dodali do operacji edycji mozliwosc odkomentowywania
i zakomentowywania wyrazen oraz dodawania blokow
komentarzy i zakomentowywania linii


* 18.02.2023

*bold*
/italic/ 

╭        ╭         ╮                                   ╮
│ define │ map f l │                                   │
│        ╰         ╯                                   │
│   ╭                                                ╮ │
│   │ march l                                        │ │
│   │                                                │ │
│   │    ╭ ◹╭    ╷    ╮ ◹╭  ╭     ╮  ╭         ╮ ╮ ╮ │ │
│   │    │  │  h │  t │  │  │ f h │ ◿│ map f l │ │ │ │ │
│   │    ╰  ╰ ◿  ╵ ◿  ╯  ╰ ◿╰     ╯ ○╰         ╯ ╯ ╯ │ │
│   │    ╭ ◻╭  ╮        ◻╭  ╮ ╮                      │ │
│   │    │  │  │         │  │ │                      │ │
╰   ╰    ╰  ╰  ╯         ╰  ╯ ╯                      ╯ ╯


╭        ╭         ╮                  ╮
│ define │ map f l │                  │
│        ╰         ╯                  │
│ ╭                                 ╮ │
│ │ match l                         │ │
│ │                                 │ │
│ │ ╭ ┏      ┓ ┏  ┓ ╮               │ │
│ │ │ ┃      ┃ ┃  ┃ │               │ │
│ │ ╰ ┗      ┛ ┗| ┛ ╯               │ │
│ │ ╭ ╓      ╖ ╓ ╭        ╮     ╖ ╮ │ │
│ │ │ ║ head ║ ║ │ f head │     ║ │ │ │
│ │ │ ║ ____ ║ ║ ╰_______ ╯____ ║ │ │ │
│ │ │ ║      ║ ║ ╭            ╮ ║ │ │ │
│ │ │ ║ tail ║ ║ │ map f tail │ ║ │ │ │
╰ ╰ ╰ ╙      ╜ ╙ ╰            ╯ ╜ ╯ ╯ ╯

⋮

◴
▴◹○
▾
▲
▼

▮◀◀  ▮◀  ▶/▮▮  ▶▮  ▶▶▮

Pomalu sobie pomysliwamy
zeby quote i quasiquote implementowac
jako rozszerzenia (tyle ze musialyby byc
dostepne i wstawiane podczas parsowania)

* 17.02.2023

Wiele bledow udalo sie wczoraj naprawic, ale na pewno
sa tez takie, ktorych nie udalo sie znalezc ani obsluzyc.

Co nam teraz pozostaje:
- zrobmy tego delete-forward!
- poprawmy parser tak, zeby zamiast '() wstawial
  (empty) - tam gdzie powinien

To sa jednak rzeczy do scommitowania w kolejnym tygodniu
(choc zrealizowac je mozemy juz dzis)

Natomiast w weekend bysmy sie zajeli uzupelnieniem
ELSowego pejpera o referencje i kody CCS (na pewno
trzeba tez dodac medc.mark.dev i ewentualnie Bochser
oraz ten drugi GRASP)

OK, czyli moze na poczatku przyszlego tygodnia by sie
udalo miec delete-character! i tematyke edycji z grubsza
zamknieta (modulo ewentualne bugi)

Natomiast w dalszej kolejnosci mamy:
- obsluge komentarzy
- obsluge specjalnej skladni
- otwieranie i zamykanie plikow
- scrollowanie ekranu
- dzielenie ekranu

Zakladamy, ze to minimum do ELS (choc oczywiscie
mozemy sie pomylic), a jesli tak, to moze sie jeszcze
uda:

- mechanizm rozszerzen (we wszystkich klientach)
- rozszerzenie Button
- obsluga gestow (glownie a Androidzie, ale wszedzie
  indziej czemu nie?)

Natomiast celowalibysmy w to, zeby te funkcjonalnosci
byly juz implementowane w samym GRASPie.

* 16.02.2023

Ostatni przypadek testowy wykazal problem z robieniem "undo!"
merge'a, wiec to nim bysmy sie dzis zajeli.

Poza tym sprobowalibysmy przetestowac operacje na tekscie,
a jezeli czas pozwoli, to rowniez bysmy sprobowali
zrobic delete-backward!

OK, z tym merge'owaniem to sprawa wydaje sie nieco grubsza,
bo wyglada na to, ze operacja inverse nie dziala prawidlowo

Byc moze jednak bedzie to okazja do tego, zeby usunac
pole "document" z wiekszosci operacji edycji.

Ale bedzie trzeba albo dodac dodatkowe pole do

(SplitElement with: Space
              at: Cursor := (the-cursor)
	      in: pair := (the-document))

badz

(MergeElements removing: Space
               at: Cursor := (the-cursor)
               in: pair := (the-document))

albo moze tak:

(SplitElement with: Space at: Cursor)
(MergeElements removing: Space after: Cursor)

tak zeby

(inverse (MergeElements removing: Space after: Cursor))
= (SplitElement at: Cursor with: space)


* 15.02.2023

Mamy zrobione wstawianie znakow w atomy
i to jako tako dziala.

Ale duzo rzeczy jeszcze nie dziala, wiec
plan jest taki, ze:

- chcemy popisac troche testow dla funkcjonalnosci,
ktora mamy, i dla tej, ktorej jeszcze nie mamy

- zrobic scalanie historii kasowania znaku
  (analogicznie do scalania historii dodawania
  znaku)

- oraz naturalnie zaimplementowac
  delete-forward!

Commity moga byc robione dopiero dzis i jutro,
a nastepny w niedziele, dlatego byloby super
zamknac do jutra kwestie zwiazane z edycja.

* 13.02.2023

Wczoraj udalo sie zrealizowac (1). Dzisiaj
bysmy sie sprobowali zajac (2).

Ale trzeba ustalic nieco szczegolow, bo
zasadniczo chcemy, zeby kursor zachowywal
sie poprawnie, tzn. zeby operacja "redo!"
po wykonaniu "undo!" dzialala tak jak wczesniej.

Ale czy rzeczywiscie musimy sie tym martwic?
Operacje zapamietuja sobie przeciez polozenie
kursora, na ktorym operuja.

No dobra, spojrzmy zatem na [[analiza-edycji]] (28.01.2023)

* 12.02.2023

Na razie napisalismy wiekszosc pejpera - zostaly
nam jeszcze tylko referencje i kategoryzacje.

Natomiast teraz chcemy:
1. wyjasnic dlaczego jak dodajemy [] do "toplevelu",
to kursor jest zle pozycjonowany

2. zaimplementowac delete-backward! z obsluga historii

3. zaimplementowac delete-forward!?


* 09.02.2023

Wczoraj udalo sie poprawic blad w historii. Natomias
wczorajsze cele zasadniczo pozostaja w mocy, ale
do tego dochodzi jeszcze poprawienie edycji stringow.

* 08.02.2023

Dzisiaj na pewno chcemy przebadac i naprawic system
"undo!", i jakby sie udalo, to takze zaimplementowac
delete-backward! i zastanowic sie, co zrobic z
delete-forward!.

Mozna tez juz pomalu myslec o zgloszeniu na ELS.

* 07.02.2023

Teraz rzeczy do zrobienia:
- optymalizacja historii: chcemy scalac ze soba operacje
InsertCharacter o ile naleza do tej samej klasy
(czyli dodawanie spacji albo dodawanie nie-spacji)
no i oczywiscie spelnione sa warunki ciaglosci kursora.

To jedna rzecz.

Druga rzecz, to chcemy przetestowac czy operacje
dzielenia i scalania atomu dobrze dzialaja.

Trzecia rzecz wreszcie, to chcemy zaimplementowac
operacje kasowania.

* 06.02.2023

Mamy mala zagwozdke dotyczaca tego, w jaki sposob reprezentowac
usuwanie znaku w sytuacji, gdy robimy delete-forward! - ale
to na szczescie jeszcze nie jest palaca kwestia.

No dobra, dzis zajelibysmy sie tym:
- jezeli jestesmy na granicy atomu (lewej albo prawej)
  i wstawiamy bialy znak, to InsertCharacter powinien
  dotyczyc nie tego atomu, tylko graniczacej spacji
- Space powinno implementowac Textual
- jezeli wstawiamy bialy znak do srodka atomu, to powinnismy
  wygenerowac operacje Split, natomiast jezeli kasujemy
  spacje z wnetrza atomu, to powinnismy wygenerowac operacje
  Join

I taki oto jest plan na dzis.

No i OK. I teraz mamy takie cus:

(define-interface Textual ()
  (insert-char! c::char index::int)::void
  (delete-char! index::int)::char
  (char-ref index::int)::char
  (truncate! length::int)::void
  (subpart start::int)::Textual
  (text-length)::int
  )

Natomiast po stronie spacji to mamy metody:
- insert-space!
- insert-break!
- delete-space!

oraz funkcje
- insert-space!
- insert-break!
- insert-whitespace!
- delete-space!
- join-spaces!
- split-space!

Dobrze by bylo, gdybysmy przynajmniej pojeciowo
sprobowali sobie zmapowac, czy tez wypowiedziec
relacje, pomiedzy join-spaces! oraz split-space!,
a metodami subpart oraz truncate! interfejsu
Textual.

Otoz: subpart i truncate! sa uzywane w funkcji
insert! w przypadku dzielenia atomu.

Czyli teoretycznie funkcje "split-space!" moglibysmy
zaimplementowac analogicznie.

Ale jednak pomysl mamy duzo lepszy - usunmy
funkcje subpart i truncate, i zamiast nich
stworzmy metode split!

OK, to mamy:
- metode split! zamiast truncate! i subpart w Textual
- Space jako instancje Textual


* 04.02.2023

Wczoraj udalo sie wprowadzic InsertCharacter i RemoveCharacter
- tzn dodawanie znakow do obiektow Textual - ale koszt tego
przedsiewziecia byl taki, ze teraz mamy zepsuta obsluge spacji.

Wydaje sie tez, ze chcielibysmy:
- uzywac nowej metody (cursor) do wyliczania polozenia
kursora
- usunac reczne manipulacje kursorem z kodu
- moze bysmy zrobili tak, ze po prostu funkcja apply!
bedzie zwracala kursor, i usunelibysmy metode
(cursor)?


* 03.02.2023

wczorajszy plan o refaktoryzacji "Extract" pozostaje w mocy.
Ale do tego dochodzi jeszcze kilka pomyslow:

- na razie wydaje sie, ze probujemy zrobic takie cos:
  edycja: wcisniecie klawisza -> dispatching -> dodanie operacji
  -> wykonanie operacji -> dispatching -> wlasciwa edycja
  cofanie: wybor operacji -> dispatching -> wlasciwa edycja

  gdzie "wykonanie operacji" to albo "insert!" albo "extract!",
  natomiast historyczne operacje to Insert albo Remove.

  Mozna rozwazyc, czy nie lepiej po prostu miec operacje
  InsertExpression i RemoveExpression, albo moze zostawmy
  juz to i zamiast tego dodajmy InsertCharacters oraz
  RemoveCharacters, a takze SplitElements i MergeElements

Ale moze na razie to olejmy? Niech sobie bedzie ten
podwojny dispatching.

Byc moze tez bysmy chcieli sprawic, zeby Space bylo Textual
(ale akceptowalo tylko #\space i #\newline)?

Na razie olewamy.

No OK, wyglada na to, ze problemem jest to, ze odwrotnosc
"Insert" w przypadku znakow nie dziala najlepiej.

Dlatego moze dodamy operacje InsertCharacter i RemoveCharacter

OK, one zostaly dodane.

Teraz jednak wydaje sie, ze bylby sens, zeby Space
byl Textual.

* 02.02.2023
  
kilka planow na dzis:
- zrefaktoryzowac extract! w taki sposob, zeby biezacy
  "extract!" stal sie "extract-from-cell!" albo cos takiego,
  natomiast "glowny" extract! zeby dispatchowal:
  1. jezeli rodzicem wyrazenia jest pair?, to wywolujemy
     extract-expression-from-cell!
  2. jezeli docelowym wyrazeniem jest atom, to wywolujemy
     extract-character-from-atom!
  3. jezeli docelowym wyrazeniem jest text, to wywolujemy
     extract-character-from-text!
 (4. jezeli idzie o rozszerzenia, to na razie nie wiemy
     co robic, ale kiedys na pewno wymyslimy)

Trzeba tez bedzie cos pomyslec o refaktoryzacji, bo wydaje sie,
ze niektore rzeczy sa niepotrzebnie rozbite na (document-operations).
(editor-operations) oraz (history) - a wiekszosc operacji w tych
modulach dotyczy edycji dokumentu!

No, ale w praktyce wyszlo tak, ze dodalismy interfejs Textual,
i implementacje w Atom oraz Text.

Jeszcze bysmy chcieli wywalic te funkcje:

(atom-length a::Atom)
(insert-char! c::char a::Atom index::int)
(delete-char! a::Atom index::int)
(truncate-atom! a::Atom length::int)
(atom-subpart a::Atom start::int)

i zastapic je uzyciem metod interfejsu.

* 01.02.2023

Dzis bysmy sie zajeli tym, zeby "undo!" i "redo!" przy dodawaniu
spacji i pojedynczego znaku dzialalo poprawnie

Zaczniemy od pojedynczego znaku.

Nie ma problemu z dodawaniem znaku, poniewaz ten przypadek
obsluzylismy w funkcji "insert!".

Jednak funkcja "extract!" zostala przemianowana z funkcji
"take-cell!", ktora zawierala w sobie zalozenie, ze dotyczy
wyodrebniania elementow z komorek.

Teraz bedziemy chcieli odejsc od tego zalozenia.

Tzn. moze w okreslonych warunkach biezaca funkcja bedzie
sie nazywac "extract-from-cell!"

Powinnismy natomiast okreslic warunki wyodrebniania.

(extract! at: cursor from: document)

zasadniczo dziala w taki sposob, ze wyrazenie
znajdujace sie pod kursorem zostaje wyodrebnione.

I teraz tak: jezeli kursor jest "pelny", to

(eq? (the-expression at: cursor)
     (the-expression at: (cdr cursor)))

Czyli zasadniczo sprawdzamy, kto jest rodzicem naszego elementu:
- jezeli jest to para (a nasz element to nie spacja)
  to wywolamy "extract-tile-from-cell!"
- jezeli jest to atom, to usuwamy znak i zwracamy go
- jezeli jest to spacja, to zwrocimy albo nowa linie, albo
  znak spacji - chyba ze spacja jest pusta, wtedy 
  albo scalamy elementy (jesli mozemy), albo nic
  nie robimy

No dobra, czyli przychodzi nam do glowy kolejna para operacji:

(SplitElement at: Cursor with: Space)
(MergeElements at: Cursor removing: Space)

ktore jednak mozna uznac za

(Remove element: Space from: Cursor)
(Insert element: Space at: Cursor)

* 31.01.2023

Musimy dokonac analizy intelektualnej problemu kursora
i historii.

Wydaje sie bowiem, ze mamy dwa rodzaje operacji:
drag&drop, ktory nie powinien wplywac na polozenie
kursora (a moze moze?) oraz edycje z klawiatury,
ktora ewidentnie wplywa na polozenie kursora

Byc moze latwiej bedzie zalozyc, ze drag&drop
rowniez wplywa na polozenia kursora (bo zasadniczo
to sie wydaje nie miec znaczenia), i ze zawsze
umieszczamy kursor za dodanym elementem
albo przed usunietym elementem. 

-----


[Insert element: (f) at: (1 2 1 1)]
[Insert element: ('i') at: (1 3 1 1)]

===>
[Insert element: (fi) at: (1 2 1 1)]
[Insert element: ('n') at: (2 3 1 1)]

===>
[Insert element: (fin) at: (1 2 1 1)]
[Insert element: ('e') at: (3 3 1 1)]

===>
[Insert element: (fine) at: (1 2 1 1)]

Warunek jest taki:
- jezeli ostatnia operacja to wstawienie atomu A
dlugosci L na pozycji (_ n . x), a kolejna operacja
to wstawienie znaku C na pozycji
(L (+ n 1) . x), to zmieniamy operacje w historii
tak, ze jest to dopisanie symbolu AC na pozycji (_ n . x).


* 30.01.2023

OK, to teraz:
- albo piszemy testy jednostkowe
- albo probujemy implementowac poszczegolne
  funkcjonalnosci (pamietajac o zaimplementowaniu
  undo! i redo! oraz o polozeniach kursora)

Wydaje sie tez, ze trzeba przemyslec sprawe
zachowania kursora w kontekscie operacji
historycznych oraz drag&dropa.

Co do drag&dropa to mamy pewna koncepcje.


* 28.01.2023 

<<analiza-edycji>>

Plan na teraz jest taki:
1. wypisujemy sobie wszystkie operacje dopuszczalne
  z klawiatury (na razie bez rozszerzen, ktore wszelako
  dodamy pozniej)
2. dla kazdej takiej operacji piszemy "test jednostkowy",
uwzgledniajacy rowniez operacje "undo!" i "redo!"
3. poczatkowo napiszemy po prostu duzo testow jednostkowych,
ale wiekszosc z nich pozostanie zakomentowana
4. bedziemy powoli dodawac funkcjonalnosci, odkomentowujac
poszczegolne testy - ale przy tym bedziemy uwazac, zeby
kod pozostal w miare ladny i elegancki, wiec nie bedziemy
sie spieszyc

A kiedy to sie uda zrealizowac, to wowczas zajmiemy sie
trawersowaniem i nawigowaniem po komentarzach oraz obsluga
pelnej skladni Kawy uzytej w implementacji GRASP, zeby dalej
moc edytowac GRASPa z poziomu niego samego.

Poniewaz zas zbliza sie luty, bedzie trzeba sie zajac
napisaniem zgloszenia na ELS.

No dobra, to teraz lista (albo tabela?)

Zacznijmy od tego:

A. insert-char!

  1. jezeli element pod kursorem to tekst, to po prostu
     wstawiamy znak do tego tekstu i zwiekszamy wierzcholek
     kursora o 1

 (2. analogicznie, jezeli element pod kursorem to rozszerzenie,
     to przekazujemy znak do rozszerzenia (i to juz ewentualnie
     rozszerzenie zajmuje sie kursorem))

  3. jezeli wstawiany znak to #\[, to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to 
     tworzymy nowe pudelko
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym pudelkiem
   (c. docelowo: jezeli mamy wybrana selekcje, to owijamy selekcje
     w pudelko)

  4. jezeli wstawiamy znak #\", to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to 
     tworzymy nowy Text
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym Textem

  5. jezeli wstawiamy spacje albo nowa linie, to:
    a. jezeli jestesmy na spacji, to odpowiednio powiekszamy spacje
    b. jezeli jestesmy na atomie, to dzielimy atom i dodajemy spacje

  6. jezeli wstawiamy atomowa litere w spacje, to tworzymy nowy atom

  7. jezeli wstawiamy atomowa litere w atom, to po prostu dopisujemy
     te litere do atomu (scalajac odpowiednio operacje Insert)


B. delete-backward!

  1. jezeli jestesmy na lewej krawedzi spacji za nawiasem
     zamykajacym, to kasujemy cale wyrazenie zamykane przez
     ten nawias
  2. jezeli jestesmy na lewej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawwiasy
  3. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta, kasujemy
        wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
     (od prawej strony)
  4. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na lewej krawedzi spacji za atomem, to
     usuwamy ostatni znak z tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja poprzedzajaca
     ten atom
  6. jezeli jestesmy wewnatrz spacji, to kasujemy poprzedzajaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak przed
     kursorem. Jezeli przed kursorem nie ma zadnego znaku,
     to usuwamy spacje przed atomem, chyba ze ta spacja jest
     zerowa - wowczas scalamy biezacy atom ze wczesniejszym
     atomem
  8. jezeli jestesmy na lewej krawedzi atomu i przed atomem
     jest nawias zamykajacy (oraz pusta spacja), to kasujemy cale
     wyrazenie
  9. jezeli jestesmy na lewej krawedzi atomu albo niepustej spacji
     za nawiasem otwierajacym, to nic robimy

C. delete-forward!

  1. jezeli jestesmy na prawiej krawedzi spacji przed nawiasem
     otwierajacym, to kasujemy cale wyrazenie otwierane przez
     ten nawias
  2. jezeli jestesmy na prawej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawiasy
  3. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta,
        kasujemy to wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
       (od lewej strony)
  4. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na prawej krawedzi spacji przed atomem,
     to usuwamy pierwszy znak tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja znajdujaca
     sie za tym atomem
  6. jezeli jestesmy wewnatrz spacji, to kasujemy nastepujaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak za kursorem.
     Jezeli za kursorem nie ma zadnego znaku, to usuwamy spacje
     za atomem, chyba ze ta spacja jest zerowa - wowczas scalamy
     biezacy atom z nastepujacym atomem

  8. jezeli jestesmy na prawej krawedzi atomu i za atomem
     jest nawias otwierajacy (oraz pusta spacja), to kasujemy
     cale wyrazenie
  9. jezeli jestesmy na prawej krawedzi atomu albo niepustej
     spacji przed nawiasem zamykajacym, to nic nie robimy


* 26.01.2023

Odkrylismy, ze klawisze w kliencie terminalowym nie sa
obslugiwane poprawnie, i mozemy sie sprobowac zajac
ich naprawa.

OK, to juz zrobione.

I co daley?

Trzeba w jakis sposob usystematyzowac edycje. Ogolnie
mamy dwie kwestie:
- modyfikacja dokumentu
- modyfikacja polozenia kursora

Do tego dochodzi nam jeszcze kwestia "odwracalnosci operacji",
w tym - w szczegolnosci - odwracalnosc operacji kasowania
(oraz scalanie operacji edycji na poziomie znaku w historii)

Dobrze by bylo rowniez rozprawic sie z kwestia reprezentacji
selekcji, bo aktualnie wydaje sie, ze (the-selection-anchor)
nie dziala zbyt dobrze.

Wreszcie byloby doskonale, gdybysmy mieli pelna obsluge selekcji.
Ale wydaje sie, ze to nie na teraz.

Ogolnie musimy tez pamietac, ze oprocz edycji z klawiatury
oraz wsparcia dla komentarzy, chcielibysmy tez w jakis sposob
reprezenotwac quote'y i unquote'y.

Natomiast w kwestii najpredszych zmian, warto byloby dodac
kolorowanie wybranego nawiasu, i warto by bylo tez obsluzyc
podswietlanie nawiasu na ktorym znajduje sie kursor.

* 25.01.2023

Wczoraj sie udalo zrobic dopisywanie znakow do atomow.
Dzisiaj natomiast zajelibysmy sie spacjami i nowymi liniami.

Chodzi zasadniczo o to, ze:
- znak spacji lub nowej linii na poczatku albo na koncu atomu
  powinien zostac dodany do przylegajacej spacji
- znak spacji lub nowej linii wewnatrz atomu powinien spowodowac
  przelamanie tego atomu
- znak spacji albo nowej linii wewnatrz spacji powinien
  pozostac w tej spacji
- znak spacji albo nowej linii wewnatrz Textu powinien
  po prostu zostac do niej odpowiednio dodany

Takie rzeczy chcielibysmy zaimplementowac, ale tez przy okazji
pojawia sie perspektywa refaktoryzacji - chodzi o to, czy
nie daloby sie zrobic tak, zeby to box, albo spacja, albo tekst
decydowaly o tym, w jaki sposob sie zachowac - bo ostatecznie
rozszerzenia powinny rowniez byc w stanie obslugiwac inputy
na swoj sposob.

---

po dzisiejszym dniu nasuwa sie kilka uwag:
1. dziwne zachowanie kursora
2. (the-selection-anchor) to upierdliwy mechanizm,
bo trzeba sie nim zajmowac przy kazdej aktualizacji kursora
3. chcielibysmy miec symetrie pomiedzy dodawaniem i usuwaniem
4. mamy kilka dziwnych bledow


* 24.01.2023

Ponizej jest sobie costam jakos tam napisane.

Natomiast tym, na czym zalezy nam przede wszystkim,
sa testy jednostkowe w test-editor-operations.scm.

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone - zmienic nazwe na "extract-from-box!"?

2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu pierwszego
     czyli:
     - merge-boxes!
     - merge-atoms!

4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
     - merge-texts!
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

1. insert! [lista do spacji]
   - wyodrebnic "insert-into-box!"
2. insert! [spacja do atomu]
   - rozbijamy atom na dwa - 
3. insert! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. insert! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. insert! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem



* 23.01.2023

Musimy dodac obsluge wstawiania spacji w spacje
do procedury insert!, jak rowniez obsluge pozostalych
sytuacji, takich jak:

- wstawienie znaku w Atom
- wstawienie znaku w Text
- wstawienie spacji/nowej linii w Atom
- wstawienie spacji/nowej linii w Text

Z pewnoscia chcemy tez napisac testy jednostkowe


* 22.01.2023

Mini-plan jest taki, zeby przeniesc funkcje
delete-forward!, delete-backward!, insert-character!
oraz delete! do primitive-terminal-client!
i dodac im przedrostek np. old!, tak zebysmy
mieli do nich dostep, ale zebysmy mogli zaczac
pisac nasze funkcje od poczatku.

Rzecz w tym, ze chcielibysmy, zeby te nowe funkcje
byly juz zaposredniczone w historii.

No ale. Plan na jutro rano jest taki, zeby:
- scommitowac zminy nazw z take-cell! na extract!
oraz ze splice! na insert!
- scommitowac przeniesienie funkcji z editor-operations
do primitive-terminal-client oraz nadanie przedrostka /old/
- zaczac pisac implementacje dla insert-character!
(i zmodyfikowac domyslna funkcje keymap tak, zeby
wywolywala insert-character!)


* 21.01.2023

No, to teraz mozemy radosnie
dodawac nowy ficzer edycji do GRASPa.

Najogolniej rzecz biorac, chcemy, zeby
wcisniecie klawisza powodowalo domyslnie
wywolanie 

(insert-character! (unicode-input) 
             into: (the-document) 
               at: (the-cursor))

gdzie:
- jezeli input to lewy nawias i jestesmy na spacji,
tworzymy nowe pudelko
- jezeli input to prawy nawias i jestesmy na lewym nawiasie,
atomie albo spacji, to idziemy do nastepnego zamykajacego nawiasu

dosc obszerna analize do przetrawienia mamy napisana
6 stycznia.

najblizsze commit w poniedzialek; programowanie
na telefonie jest duzo dostepniejsze, ale
na laptopie komfort pisania jest nieporownywalnie
lepszy.

OK, to z takich bardziej podstawowych rzeczy:
- chcemy zmienic nazwy z take-cell! na extract!
i ze splice! na insert!
(nie do konca juz pamietamy, dlaczego chcemy,
ale mimo wszystko nadal chcemy?)

W kazdym razie nazwy zostaly juz zmienione.

No i co dalej?

Moze bysmy usuneli:
- primitive-terminal-client
- funkcje "delete-forward!", "delete-backward!"
  oraz "insert-character!" z (editor-operations),
  zeby je moc zaimplementowac od nowa?

Nooo, tyle ze tam juz jakas funkcjonalnosc jest.

Mozemy zatem albo przeprowadzic analize tego,
co juz mamy, albo - w oparciu o wczesniejsza analize
- zaprojektowac to, co powinnismy miec.

Co dziwne, wydaje sie, ze niektore rzeczy
dzialaja.

* 19.01.2023

pozostale dwa punkty ze wtorkowej listy odhaczone

* 18.01.2023

pierwsy punkt z wczorajszej listy odhaczony.
teraz nam pozostaje dodac extend-selection
(usuwajac tego przykrego enuma)

* 17.01.2023

zadania na dzis/jutro:
- przetestowac desktop-client na asusie
  (i ew. ponaprawiac)
- uzupelnic mapy klawiatury
- dodac (shift left) oraz (shift right) jako ekspansje selekcji
  
* 14.01.2023

zbudowalismy juz zalazki map klawiatur dla
trzech klientow

teraz bysmy chcieli usunac stare zdarzenia
z modulu pane, i zastapic je nowymi

- bedzie to wymagalo translacji kodu
  zdarzenia do odpowiedniej postaci
  (w tym ustawienia parametru (unicode-input)
  tam gdzie to stosowne)

  w przypadku kazdego klienta bedzie to trzeba
  robic inaczej, i dlatego nalezy ustalic jakas
  kolejnosc:
  - najpierw klient terminalowy
  - po nim klient androidowy
  - a na koncu klient desktopowy
    (ktotego i tak nie mamy na razie jak
    przetestowac)

natomiast plany dlugofalowe:
+ skonczyc ta refaktoryzacje
+ zaimplementowac edycje
+ obsluga komentarzy (renderowanie i nawigacja)
+ obsluga uzytych rozszerzen Kawy/rezygnacja z nieuzytych rozszerzen
+ ladowanie i zapisywanie plikow; podzial ekranu
+ zgloszenie na ELS
+ mechanizm rozszerzen
+ poszczegolne rozszerzenia + sukcesywny rozwoj API do rysowania
+ evisulator
+ edytor grafow
+ obsluga selekcji (kopiowanie, wklejanie, usuwanie, historia)
+ naprawianie bledow (w tym zwiazanych z drag&dropem)
+ prezentacja na ELS
+ pierwsze wydanie, 2 aplikacje w sklepie
+ zgloszenie na StrangeLoop
+ siec spolecznosciowa

+ SICP - GRASP edition
+ The Little Schemer - GRASP edition
  (i podobnie: The Seasoned Schemer, The Reasoned Schemer)
+ The Dream Machine - GRASP edition
+ The Way Things Work - GRASP edition

+ The Art of Metaprogramming in Scheme

ok, tosmy sobie odplyneli

teraz do roboty: zmieniamy sposob obslugi
klawiszy w kliencie terminalowym - ale trzeba
jeszcze pomyslec co z obsluga myszy/wskaznikow

ok, klient terminalowy juz obskoczony.
teraz jeszcze tylko zostaje androidowy i desktopowy.

na razie sie zajmiemy androidowym

ok, wyglada na to ze to tez sie udalo.


* 13.01.2023

Mamy sobie 3 klienty. I teraz dla tych
3 klientow bedziemy chcieli zbudowac
moduly (android-key-map) (desktop-key-map)
oraz (teminal-key-map).

* 12.01.2023

No dobra, to teraz - zeby byla jasnosc - zaczynamy
od uwspolnionego systemu obslugi zdarzen, w ktorym
bedzie tylko zdarzenie 'key-typed', a funkcje beda
definiowane w pliku init.scm.

Na razie nie robmy hierarchicznej obslugi, bo to
moze byc overengineering.

Dopiero jak to bedzie gotowe, zajmiemy sie 'wstawianiem
znakow', ze szczegolnym uwzglednieniem aspektu historii
/cofania.

* 11.01.2023

trzeba obmyslic strategie implementacji
nowego podsystemu wprowadzania

W androidzie mamy:
getKeyCode(), getScanCode(), getMetaState()


w androidzie chcemy zmienic podsystem zdarzen
tak zeby na razie po prostu wypluwal zdarzenie
do logow


(active-pointers) ::(list-of int)

(pointer-position index::int) ::Position

(unicode-input)::char

w KeyboardEvent z awt mamy metode getKeyChar,
ktora zwraca kod albo CHAR_UNDEFINED.

(define-mapping (key-handler key-code)::(maps () to: void)
  (lambda ()::void
    (and-let* ((c (unicode-input)))
      (insert-character! c))))

Jeszcze trzeba rozwazyc opcje dodawania trybow,
tak zeby mozna bylo przeslaniac sobie tablice znakow
w roznych kontekstach.


(define-type (KeyMap bindings: (maps (key::int) to: () to: void)
                     parent: KeyMap))
      
* 10.01.2023

Wczorajszybi dzisiejszy dzien to glownie
walka z ewaluacja w kliencie androidowym
(i to trzeba odnotowac)


Jutro j pojutrze beda comity:
- ocpowiedziec na issue
- commitnw grasp-android

- zarchiwizowac grasp-android
- scomitowac zmiany tutaj

Na razie plan jest taki, ze chcemy
ujednolicic konfiguracje po stronie
androida, terminala i awt, szukajac
najwiekzzsgo wxpolnego mianownika

nastepnie bysmy te konfiguracje
przeniesli do init.scm

nastepnie bysmy juz zaczeli walke
z podpinaniem funkcji do edycji
dokumentu

fajnie by bylo to zrobic do konca
stycznia - i jeszcze obsluge
komentarzy w rendererze, oraz
otwieranie i zapisywanie plikow
oraz podzial ekranu

na pewno tez troche pracy bedzie
trzeba poswiecic zeby dopiescic
klienta awt

na dalszy ogien idzie mechanizm
rozszerzen oraz ewaluacja wyrazen
roraz juz partykularne rozszerzenia
(Img src: ...), wizualny ewaluator,
edytor grafow, chmura punktow

natomiast priorytetem powinno
byc doproeadzenie do sytuacji
w ktorej GRASP rozwijamy w GRASP,
a nie w Emacsie

----------------------------------

ok, to co teraz robimy?

trzeba bedzie rozehrac zdarzemia
z awt na kawalki

moze warto zrobic tabelke

|---------+------------+-------------+-----------|
| system  | press      | release     | type      |
|---------+------------+-------------+-----------|
| AWT     | keyPressed | keyReleasee | keyTyped  |
|---------+------------+-------------+-----------|
| Lantrna |            |             | readInput |
|---------+------------+-------------+-----------|
| Android | onKeyDown  | onKeyUp     |           |
|---------+------------+-------------+-----------|

Ok, i teraz co?

Teraz musimy odwzorowac klawisze i sekwencje
w ich nazwy. Na przyklad

(on-key '(ctrl alt shit x) cut-selection!)

czy cos

i teraz bysmy sobie zrobili takie cos,
ze tlumaczylibysmy sekwencje na wartosc
typu long, i systemy zdarzen w poszczegolnych
klientach robilyby to samo - i mielibysmy
tablice haszujaca, ktora mapuje nam
klawisze na odpowiednie procedury

Poniewaz jednak nie chcemy tracic
dotychczasowej funkcjonalnosci,
moze wypiszmy sobie jakie do tej porg
mielismy wiazania w poszczegolnych
klienach:

** klient terminalowy:

  (set! (on-key-press KeyType:ArrowLeft)
	(lambda ()
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowRight)
	(lambda ()
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowUp)
	move-cursor-up!)

  (set! (on-key-press KeyType:ArrowDown)
	move-cursor-down!)

  (set! (on-key-type #\x) exit)

** klient desktopowy

  (set! (on-key-press KeyEvent:VK_LEFT)
	(lambda _
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_RIGHT)
	(lambda _
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_UP)
	move-cursor-up!)

  (set! (on-key-press KeyEvent:VK_DOWN)
	move-cursor-down!)

  (set! (on-key-press KeyEvent:VK_Z)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:undo!)))))

  (set! (on-key-press KeyEvent:VK_Y)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:redo!)))))

** klient androidowy:

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_LEFT)
      (lambda _
	(move-cursor-left!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_RIGHT)
      (lambda _
	(move-cursor-right!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_UP)
      move-cursor-up!)

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_DOWN)
      move-cursor-down!)


* 09.01.2023

wyglada na to, ze mamy takie problemy
implementacyjne:
- w wersji skompilowanej, init.scm musi
  ladowac moduly, z ktorych korzysta
- ale trzy klienty beda musialy definiowac
  on-key na swoj sposob
- ale czy rzeczywiscie?

Definicja on-key bedzie taka sama, tylko
sposob wywolania bedzie rozny.

Teraz trzeba:

- usunac key-pressed! i key-released! z (panel),
  moze tez zmienic nazwe na (pane)

- zrobic jakos tak, zeby wywolywac odpowiednia
  funkcje dla kazdego klienta

* 08.01.2023

plan jak na razie wyglada zacnie.

jego realizacje zaczelibysmy od tego, ze kazdy
klient wykonywalby plik init.scm - na poczatku
to moze byc po prostu wypisanie loga albo cos.

co wiecej, zmiany w kliencie desktopowym
i terminalowym mozemy robic na laptopie

* 07.01.2023

Usunelismy funkcje "insert!", ale jest pewien
problem z testowaniem - na telefonie mozemy
jedynie przetestowac dzialanie aplikacji
na telefon.

Poza tym jest jeszcze kwestia taka, ze chcielibysmy
zbudowac przenosny interfejs wwjscia/wyjscia
pomiedzy klientami - cos w rodzaju

(on-key '(ctrl z) undo!)

(on-key '(ctrl y) redo!)

i wowczas bysmy sobie zdefiniowali:

(on-key 'space insert-space!)

(on-key 'backspace delete-backward!)

(on-key 'delete delete-forward!)

(on-key 'enter insert-newline!)

(on-key 'left move-cursor-left!)

(on-key '(shift left) expand-selection-left!)

(on-key 'right move-cursor-right!)

(on-key '(shift right) expand-selection-right!)

Mielibysmy tez takie funkcje:

(active-pointers) ::int

(pointer-position index::int) ::Position

(unicode-input)::char

Bedziemy chcieli miec plik init.scm, zawierajacy
powyzsze definicje.

Od strony implementacyjniej bysmy chcieli miec:
- bezposrednia tablice
- tablice shift dla klawiszy sterujaych
- tablice ctrl
- tablice alt
- tablice ctrl+alt
- tablice ctrl+shift
- tablice alt+shift
- tablice ctrl+alt+shift

Albo nawet nie. Moze byc jedna tablica.

* 06.01.2023

Idealnie byloby, gdybysmy nie dodawali
zadnych nowych operacji, tylko poprzestali
na Move, Remove oraz Insert.

Dzielenie atomu odbywaloby sie na zasadzie
wstawienia spacji w atom, laczenie - na zasadzie
usuniecia spacji itd.

Trzeba to bedzie sobie rozpisac.
Move -> take-cell!, splice!
Remove -> take-cell!
Insert -> splice!

Trzeba bedzie pozmieniac nazwy:
1. insert! z modulu (history) na cos (to trywialna
   funkcja uzyta w jednym miejscu w (panel))
2. ze splice! na insert!
3. z take-cell! na extract!

I teraz: funkcje (nowe) insert! i extract!
bedziemy musieli zmienic tak, zeby dzialaly
w roznych konfiguracjach

(docelowo do extract! bedziemy chcieli
jeszcze dodac argument numeryczny, tak
zeby moc uzywac tej funkcji do obslugi
selekcji, zas splice! rowniez bedzie
trzeba do tego celu przysposobic)

No dobra, ale teraz chyba bedzie trzeba
rozwazyc

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone: wydobywamy element
     z wnetrza pudelka
2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden3. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu
     pierwszego
4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

i teraz insert! analogicznie:

1. splice! [lista do spacji]
   - juz obsluzone (wklejamy liste pomiedzy element
     poprzedzajacy spacjena kolejny element)
2. splice! [spacja do atomu]
   - rozbijamy atom na dwa
3. splice! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. splice! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. splice! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem

1. extract-tile! at: Cursor from: document
   splice-list! list at: Cursor into: document
2. merge-atoms! at: Cursor in: document
   split-atom! at: Cursor in: document
3. merge-boxes! at: Cursor in: document
   split-box! at: Cursor in: document
4. merge-texts! at: Cursor in document
   split-text! at: Cursor in: document
5. remove-characters! at: Cursor from: document
   insert-charactets! at: Cursor into: document
   
* 02.01.2023

Dwie pierwsze zmiany w nowym roku:
- archiwizacja grasp-android
- odpowiedziec na "issue" w nowym repo

Natomiast to, czym teraz bysmy sie chcieli
zajac, to edycja dokumentow z klawiatury,
czyli:

- jak piszemy [, to tworzymy nowe puste pudelko
- jak piszemy ]. to wychodzimy z pudelka

W kazdym razie to sie dzieje w kontekscie
pudelek - bo w przypadku Textu dla niesterujacych
znakow zawsze owe znaki dopisujemy (pewnym wyjatkiem
moze byc \, ale to jeszcze trzeba przemyslec)

- jak piszemy ", to tworzymy nowy Text

jak wciskamy znak drukowalny, to:
- jezeli jestesmy na spacji, to tworzymy
  nowy atom
- jezeli jestesmy na atomie, to dopisujemy
  znak

Wyjatki:
- wcisniecie spacji, gdy jestesmy na spacji,
  dodaje spacje pozioma
- wcisniecie entera dodaje spacje pionowa
- wcisniecie spacji albo entera na atomie
  powoduje rozbicie atomu (chyha ze jestesmy
  na ostatniej pozycji - wtedy edytujemy
  nastepujaca spacje)

Trzeba bedzie zaczac od napisanis testow
dla takiego czegos, oraz dodac odpowiednie
operacjendo historii edycji

Rowniez chcielibysmy obsluzyc dzialanie
klawisza backspace.

Jezeli idzie o historie, to mozemy zamodelowac:
- rozszczepienie atomu jako wstawienie spacji
- scalenie atomu jako usuniecie spacji

Dzieki temu nie musimy dodawac nowych operacji
do historii.

Mamy zatem do dodania nastepujace operacje:
