(import (define-parameter))
(import (keyword-arguments))
(import (functions))
(import (fundamental))
(import (indexable))
(import (space))
(import (cursor))
(import (primitive))
(import (document-operations))
(import (infix))
(import (match))
(import (print))
(import (extent))
(import (painter))
(import (history))
(import (text))

(define-parameter (cursor-column)::real 0)

(define (move-cursor-right!)
  (set! (the-cursor) (cursor-advance))
  (let* ((painter (the-painter))
	 (cursor-position ::Position (painter:cursor-position)))
    (set! (cursor-column) cursor-position:left))
  (set! (the-selection-anchor) (the-cursor)))

(define (move-cursor-left!)
  (set! (the-cursor) (cursor-retreat))
  (let* ((painter (the-painter))
	 (cursor-position ::Position (painter:cursor-position)))
    (set! (cursor-column) cursor-position:left))
  (set! (the-selection-anchor) (the-cursor)))

(define (expand-selection-right!)
  (set! (the-cursor) (cursor-advance))
  (let* ((painter (the-painter))
	 (cursor-position ::Position (painter:cursor-position)))
    (set! (cursor-column) cursor-position:left)))

(define (expand-selection-left!)
  (set! (the-cursor) (cursor-retreat))
  (let* ((painter (the-painter))
	 (cursor-position ::Position (painter:cursor-position)))
    (set! (cursor-column) cursor-position:left)))

(define (move-cursor-up!)
  (let* ((painter (the-painter))
	 (target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (- initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < initial-position:top)
	       (probe (+ attempt 1))))))))

(define (move-cursor-down!)
  (let* ((painter (the-painter))
	 (target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (document-extent ::Extent (sequence-extent))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (+ initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < (+ initial-position:top shift)
		   < document-extent:height)
	       (probe (+ attempt 1)))
	      )))))

(define (undo!)
  (let ((document-history ::History (history (the-document))))
    (document-history:undo!)))

(define (redo!)
  (let ((document-history ::History (history (the-document))))
    (document-history:redo!)))


(define/kw (insert-character! c::char)
  ::boolean
  ;; musimy pamietac ze dzialana dokonywane poprzez
  ;;te funkcje powinno sie dac cofac za pomoca "undo!"
  (and-let* (((isnt c eqv? #\null))
	     (`(,tip ,top . ,subcursor) (the-cursor))
	     (parent ::Indexable (the-expression at: subcursor))
	     (item ::Indexable (parent:part-at top))
	     (final ::Indexable (item:part-at tip)))
    (cond
     ((isnt final eq? item)
      (WARN "attempted to insert character "c" to non-final position")
      #f)
     ((Space? item)
      (cond
       ((eqv? c #\") 
	;; wstawiamy nowy obiekt typu Text
	(let ((operation ::Insert (Insert element: (cons (Text) '())
					  at: (the-cursor)))
	      (history ::History (history (the-document))))
	  (operation:apply! (the-document))
	  (history:record! operation)
	  (move-cursor-right!)
	  #t))
       
       ((is c in '(#\[ #\( #\{))
	(let ((operation ::Insert (Insert element: (cons
						    (EmptyListProxy
						     (Space
						      fragments:
						      (cons 0 '())))
						    '())
					at: (the-cursor)))
	      (history ::History (history (the-document))))
	  (operation:apply! (the-document))
	  (history:record! operation)
	  (times 2 move-cursor-right!)
	  #t))
       
       ((is c in '(#\] #\) #\}))
	(set! (the-cursor) (recons (parent:last-index)
				   subcursor))
	#t)
       (else
	(let ((operation ::Insert (Insert element: (cons
						    (Atom
						     (list->string
						      (list c)))
						    '())
					  at: (the-cursor)))
	      (history ::History (history (the-document))))
	  (operation:apply! (the-document))
	  (history:record! operation)
	  (set! (the-cursor) (recons* 1 (+ top 1) subcursor))
	  (set! (the-selection-anchor) (the-cursor))
	  #t))))
     (else
      (let ((operation ::Insert (Insert element: (cons c '())
					at: (the-cursor)))
	    (history ::History (history (the-document))))
	(operation:apply! (the-document))
	(history:record! operation)
	(set! (the-cursor) (recons (+ (head (the-cursor))
				      (length operation:element))
				   (tail (the-cursor))))
	(set! (the-selection-anchor) (the-cursor))
	#t)))))
